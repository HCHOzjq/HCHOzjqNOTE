### 网络字节序：

htonl：本地->网络（IP）

htons：本地->网络（PORT）

ntohl：网络->本地（IP）

ntohs：网络->本地（PORT）

### IP地址转换：

`int inet_pton(int af,const char *src,void *dst)`将本地转网络

- af：协议簇：AF_INET、AF_INET6
- src：传入，IP地址（点分十进制）
- dst：传出，转换后的网络字节序的IP地址。
- 成功返回1
- 异常返回0
- 失败返回-1

`const char* inet_ntop(int af,const void *src,char*dst,socklen_t size)`将网络转本地

### socket：

`int socket(int domain,int type,int protocol);`

- domain：AF_INET、AF_INET6
- type：SOCK_STREAM、SOCK_DGRAM
- protocol：0（根据type去选择协议，stream是tcp，dgram是udp）
- 成功返回，新套接字所对应字节描述符。

### BIND：

`int bind(int sockfd,const struct sockaddr*addr,socklen_t addrlen);`给socket绑定一个地址（IP+port）

- sockfd函数返回值

  - struct sockaddr_in addr;
  - addr.sin_family=AF_INET;
  - addr.sin_addr.s_addr=htonl(INADDR_ANY);

  addr:(struct sockaddr*)&addr

  addrlen:sizeof(addr)地址结构大小

- 成功：0
- 失败：-1

### Listen

`int liisten(int sockfd,int backlog);`设置可同时连接的最大数量

- backlog：可同时连接的最大数量
- 成功：0
- 失败：-1

### accept

`int accept(int sockfd,struct sockaddr*addr,socklen_t*addrlen);`阻塞等待

- sockfd：socket的返回值
- addr：传出参数。成功与服务器建立连接的那个客户端的地址结构。
- addrlen：传入传出。入：addr的大小。出：客户端addr的实际大小，所以需要取地址。

- 成功返回能与服务器进行数据通信的socket对应的文件描述符
- 失败返回-1，errno。

### connect

`int connect(int sockfd,const struct sockaddr*addr,socklen_t addrlen`使用现有的socket与服务器连接

- sockfd:socket返回值
- addr:服务器地址结构
- addrlen:服务器结构的大小
- 失败返回-1，errno。
- 如果不采用bind绑定客户端地址结构，采用隐式绑定。

//图床坏了呜呜呜，算了这个以后多敲就可熟悉了。。。

### mss最大报文长度

### 滑动窗口机制

- 来指定缓冲区大小的

### 