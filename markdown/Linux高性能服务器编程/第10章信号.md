### 发送信号

`int kill(pit_t pid,int sig);`

- 把sig发给目标进程。
- 若pid>0发给该进程，若pid=0发给本进程组内的其他进程，若pid=-1，发给除了init进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限，pid<-1，发送给组ID为-pid的进程组中的所有成员。

- 如果sig为0，则kill函数不发送信号。但将sig设置为0可用来检测目标进程或进程组是否存在，因为检测工作总在信号发送之前就执行。不过这种检测方式是不可靠的。一方面由于进程PID的回绕，可能导致被检测的PID不是我们期待进程的PID，另一方面，这种检测方法不是原子操作。
- 成功返回0，失败返回-1并设置errno。

### 信号处理方式

信号处理函数只带有一个整数参数，该参数用来指示信号类型。信号处理函数应该是可重入的，否则很容易引发一些竞态条件。在信号处理函数中严禁调用一些不安全的函数。

- `#define SIG_DFL((__sighandler_t)0)`

- `#define SIG_IGN((__sighandler_t)1)`
- SIG_IGN表示忽略目标信号。SIG_DFL表示使用信号默认处理方式。默认处理方式有：结束进程（Term）、忽略信号（Ign）、结束进程并生成核心转储文件、暂停进程（Stop）、以及继续进程（Cont）。

- 如果程序在执行处于阻塞状态的系统调用时收到信号，并且我们为该信号设置了信号处理函数，则默认情况下系统调用被中断，并且errno被设置为EINTR。我们可用sigaction函数为信号设置SA_RESTART标志以自动重启被信号中断的系统调用。
- 对默认行为是暂停的信号，如果我们没有设置信号处理函数，则他们可中断某些系统调用。

### signal系统调用

`_sighandler_t signal(int sig,_sighandler_t handler)`

- sig参数指出要捕获的信号类型。handler参数是_sighandler_t类型的函数指针。
- 成功返回前一次调用signal函数传入的函数指针，或者是默认的函数指针SIG_DEF。
- 出错返回SIG_ERR，设置errno。

### sigaction系统调用

`int sigaction(int sig,const struct sigaction*act,struct sigacton*oact);`

- sig指出要捕获的信号类型。
- act指定新的信号处理方式。oact参数输出之前的处理方式。

前面部分是对一些函数进行介绍，比较杂且多，就不多写了~

---



- SIGHUP：当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。
- SIGPIPE：默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。它的默认行为是结束进程，而我们一般不会让程序退出。其errno为EPIPE
- 