# 第二章 innodb存储引擎

## 1、innodb的体系架构

- 数据结构，磁盘数据，重做日志缓冲等。
- Master thread负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性。
- IO thread大量使用了AIO异步IO来处理IO请求，有四种不同的线程。
- Purge thread，用来回收undo页。
- 内存
  - 缓冲池，查询和更新主要先在缓冲池中进行。
  - LRU List，Free List，Flush List管理缓冲池。
    - LRU中有一个教midpoint的位置。当读取到新页的时候，是放到这个位置上，目的是为了防止扫描操作将缓冲池中最经常使用的页面移出。
  - 重做日志缓冲
    - innodb首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。
      - Mater thread每一秒会将重做日志缓冲刷新到日志文件。
      - 每个事务提交的时候将重做日志缓冲刷新到重做日志文件。
      - 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。
  - 额外的内存池

## 2、checkpoint技术

- Write Ahead Log，在事务提交时，先写重做日志，再修改页。
- 目的：缩短数据库恢复时间，缓冲池不够用时，将脏页刷新到磁盘，重做日志不可用时，刷新脏页。

## 3、Mater Thread工作方式

- 内部有多个循环
- Loop，主循环，大多数操作是在这个循环中，其中有两大部分的操作，每秒操作和每10秒操作。
  - 每秒：日志缓冲刷新到磁盘中，即使这个事务还没提交。合并插入缓冲，至多刷新100个innodb缓冲池的脏页到磁盘中。如果当前没有用户活动，则切换到background loop。
  - 每10秒：刷新100个脏页到磁盘，合并至多5个插入缓冲，将日志缓冲刷新到磁盘，删除无用的undo页，刷新100个或者10个脏页到磁盘（该操作得看脏页占比）
- background loop
  - 删除无用的undo页
  - 合并20个插入缓冲
  - 跳回主循环
  - 不断刷新100个页直到符合条件。

## 4、Innodb关键特性

- 插入缓冲（提升性能）
  - 插入的B+树其索引是辅助索引同时索引不是唯一的。也就是每次插入的时候插入到一个缓冲池中。假如缓冲池中没有改索引，就先放入到一个insertBuffer对象中。
  - 为什么不要唯一的，假如是唯一的话，就必须跑去数据库查看该数据是不是唯一的，这样子就失去了缓冲的意义。
  - 该数据结构是B+树，该结构的非叶子节点包含该插入语句所操作的页信息（space,offset)。还有一个marker用来兼容老版本。
  - 叶子节点信息出了非叶子的信息外还多出了一个metada，该信息保存着该语句的插入顺序等。
  - Insert Buffer Bitma页是用来追踪辅助索引页。
    - 辅助索引页被读取到缓冲池的时候。
    - 合并的时候，内存少了就强制进行一个合并。
    - Master thread10秒回给一次操作。
- 两次写（提升数据可靠性）
  - 当一个DML语句发送的同时，数据库宕机了。这个时候没法通过日志对数据进行恢复，因为其本来的数据已经是错误的了。
  - 当触发脏页刷新的时候，先将数据刷新到内存中的double write buffer中。
    - 接着数据分两次写入磁盘共享表空间中。
    - 写完后，再将double write buffer中的数据写入实际的各个表空间文件中。
  - 当系统崩溃的时候，系统会从磁盘共享表空间中去找到该页的一个最近的副本，将其复制到表空间文件，再用redolog，完成了恢复过程。
  - 副作用，造成磁盘负载
- 自适应哈希索引
  - innodb自动检查各索引的查询频率，假如频率过高就自动建立哈希索引。
- 异步IO
- 刷新邻接页
  - 每次刷新看看隔壁是不是脏的。

# 第二章 文件

## 28、日志

- 错误日志：启动、运行、关闭的时候的记录。
- 慢查询日志：通过该日志可以查询到哪些语句运行比较慢，从而排查哪些语句出错。
- 查询日志：记录了所有对Mysql数据库请求的信息。
- 二进制日志：记录了对mysql数据库执行更改的所有操作。
  - 恢复，复制，审计（防止MySQL注入）

## 27、数据库的表空间

- 一个表是由：段->区（固定1MB）->页（默认16KB）组成的。页有时候被叫做块。
- 表空间是innodb存储引擎的最高层。可以通过参数`innodb_file_per_table`将表区分到不同的文件中去。每个文件只包含：表数据、索引和插入缓冲Bitmap页。对于二次写缓冲，回滚，插入缓冲索引页，系统事务信息等还是放在原来的共享表空间中去。

