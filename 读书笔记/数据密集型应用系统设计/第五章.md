### 主从复制

- 领导者（主库）数据写入请求的唯一接收者。
- 追随者（从库，备库，热备）。
- 当领导者将新数据写入本地存储时，它会将数据变更发送给所有的追随者。这个过程叫复制日志记录或叫本更流。追随者拉取日志，并相应更新本地数据库副本。
- 客户想要读取数据的时候，它可以向领导者或追随者查询。但只有领导者有写操作权限。
  - 热备份是指能接受客户端请求的副本。
  - 而温备只是追随领导者，但不处理客户端的任何查询。

### 同步复制和异步复制

- 同步和异步百度一般都有。同步意思是一个进程得要等待另外一个进程的响应。异步的意思是两个进程之间不用等待。
- 半同步指的是至少有两个节点是同步的，拥有最新的数据副本：主库和同步从库。这种配置叫做半同步。

### 如何设置一个新从库

- 保存一个快照，需要第三方工具。
- 将快照复制到新的从库节点。
- 从库连接到主库，拉取快照之后发生的所有数据变更。
- 当从库处理完快照后积压得数据变更了。就说它赶上了主库。

### 宕机的处理情况

- 从库失败：追赶恢复
  - 从库可以从日志中知道发生故障之前处理的最后一个事务。
  - 之后可以连接上主库，请求再从库断开连接时发生的所有数据变更。
- 主库失效：故障切换
  - 将其中一个从库提升为新的主库。需要重新配置客户端，以将他们的写操作发给新的主库，其他从库需要开始拉取来自新主库的数据变更。这个过程叫做故障切换。
    - 确认主库失效：崩溃，停电，网络问题。一半用超时来判断有没有出问题。
  - 选择一个新的主库。这可以通过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的控制器节点来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库。重新配置系统以启动新的主库。客户端现在需要将他们的写请求发送给新主库。同时系统需要让老领导认可新领导，成为一个从库。
- 故障切换的麻烦：
  - 在采用异步复制的情况下，新主库没有收到老主库宕机前最后的写入操作。在选出新主库后，如果老主库重新加入集群。新主库在此期间可能会收到冲突的写入，那这些写入改如何处理？最常见的方式是简单丢弃老主库非复制的写入，这很可能打破客户对数据持久化的期望。
  - 脑裂的出现：有两个主库，需要删除其中一个（爆彼之头）

### 复制日志的实现

- 直接复制语句的话，不太行，因为可能会遇到一些有副作用的语句：例如触发器
- 逻辑日志复制：复制和存储引擎使用不同的日志格式，这样可以使复制日志从存储引擎内部分离开来。

### 复制延迟问题

- 读己之写
  - 读用户可能已经修改过的内容的时候，都从主库读。例如：社交网络上的用户个人资料信息通常只能由自己编辑，而不能他人编辑。那么：读取的时候可以从主库读取自己的档案，从从库读取其他用户的档案。
  - 当数据库中的大部分内容都可以被用户编辑，那么这种方法就没什么用了，因为大部分内容都得从主库读取，那么这个时候可以追踪上次更新时间，假如更新时间在一分钟内，就得从主库读，假如大于一分钟就得从库外读。
  - 客户端可以保存最近一次写入的时间戳，系统需要确保从库为该用户提供任何查询时，该时间戳前的变更都已经传播到了本从库中。如果从库不够新，则可以从另外一个库中读取。

- 时光倒流
  - 两次读取读到的数据库，前者新，后者旧。导致本来更新的数据又没更新了。
  - 解决方法是：单调读。假如读到了比较新的数据，后续就不读取旧数据。
- 一致前缀读
  - 如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案。
  - 解决方法：一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见他们以同样的顺序出现。

### 离线的客户端（坚果壳）

### 多人编辑（多领导复制）

### 最大问题是可能发生写冲突

### 冲突检测

- 收敛到一致的状态
  - 给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUDI或者一个键和值的哈希），挑选最高ID的写入作为胜利者，丢弃其他写入。假如用时间戳这种技术被叫做最后写入胜利。
  - 为每个副本分配一个唯一的ID，ID的编号更高的写入具有更高的优先级。
  - 以某种方式合并在一起。
  - 保留所有信息的显式数据结构中记录冲突。编写解决冲突的应用程序代码（diff）
- 自己解决冲突问题
  - 写时执行
    - 数据库检测到更改日志中存在冲突，就会调用冲突处理程序。
  - 读时执行
    - 当检测到冲突时，将冲突写入被存储，下一次读取数据时，会将这些多版本的数据返回给应用程序，应用程序可能会提示用户或自动解决冲突。

### 多主复制拓扑

- 主要是要解决冲突问题。