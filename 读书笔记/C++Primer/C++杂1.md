### 引用

![](D:\桌面\推文\chapte2-1.png)

1、引用并非对象，它只是为一个已经存在的对象所起的另一个名字。如图，对`yi`的操作等同于对`i`的操作。

2、引用必须定义时候赋值(初始化)。

3、因为引用并非对象，所以不能定义引用的引用。

4、引用所绑定的类型必须与引用本身一样。原因在讲引用与常量上会讲到。

### 指针

如c语言中的一样,指向一个地址,本身是一个对象。

![](D:\桌面\推文\chapte2-2.png)

1、这里`zy`用`&`取地址符,获取地址`'zy'`,用`*`接触引用,使用其地址上的内容。

![](D:\桌面\推文\chapte2-3.png)

2、可以用`nullptr`，`NULL`，`0` 初始化。

3、`void*`只是存放对象地址，在使用上可以被强转为各种指向其他类型的指针。

4、指向指针的引用

![](D:\桌面\推文\chapte2-4.png)

### const

1、要对其初始化

2、要在多个文件中使用的话，需要在声明和定义前加上`extern`

### `const`的引用

可以用任意表达式作为初始值，**因为无论怎么样编译器都会创建一个`const`的临时量**，然后再赋值给该引用，而无法更改其值。同时也解释了为什么没有`const`的引用无法在不同类型中使用引用。**因为我们使用引用的情况是为了能够通过这个引用别名去修改原来的变量，但是用了临时量去变换的话，修改的是那个临时量。**

![](D:\桌面\推文\chapte2-5.png)

### 指针和const

1、指向常量的指针不能用于修改其所指向的地址。

2、一个指针常量不能修改指针本身。

3、弄清楚指针常量和指向常量的指针最好的方法是从右往左边读。

例如下图：

`curErr`是一个常量，然后又是一个指针。

`pip`首先是一个常量指针，然后他指向的内容是一个常量的double对象。

![](D:\桌面\推文\chapte2-6.png)

### 顶层const和底层const

1、`顶层const`表示指针本身是常量。

2、`底层const`表示指针所指内容是常量。

3、`底层const`不能被忽视。

### constexpr和常量表达式

1、常量表达式是编译过程能得到结果且不会被改变的表达式。

2、`constexpr`是让编译器自己判断该表达式是不是常量表达式。

![](D:\桌面\推文\chapte2-7.png)

3、`constexpr`只对指针本身有效果，对其所指内容无效。也就是`constexpr`只和`顶层const`有关系。

### 别名

有以下两种

![](D:\桌面\推文\chapte2-8.png)

值得注意的是别名在与指针搭配的情况下，如下图：

![](D:\桌面\推文\chapte2-9.png)

其中第二行会报错，我们先看第三行的的意思，它是一个指针，指向`const char`。但是第二行意思其实是它是一个String(指针），然后是一个`const`的String，所以它得先初始化。那么`const String*s`，是一个指针，指向一个指向char类型的常量指针。

### auto

1、编译器自己分析表达式所属类型，然后声明变量。

2、在同一条语句中不能申请不同的初始基本数据类型，如：

```c++
auto a = 1,b = 1.2;//会报错
auto x = 1,y =2;//正确
```

3、忽略掉`顶层const`，如果需要就和第四行一样强调一下。

![](D:\桌面\推文\chapte2-10.png)

## decltype

1、返回一个变量的类型

2、需要类型但不需要值的情况。

3、如果作用的是变量那么就会返回该变量的所有类型(包括`顶层const`和引用)

![](D:\桌面\推文\chapte2-11.png)

其中第3行会报错，因为y也是是b的引用，且为`const int`

4、当作用的是表达式，返回表达式结果对应的类型。

![](D:\桌面\推文\chapte2-12.png)

### auto和decltype的区别

1、`dectype`的结果与表达式形式密切相关。

2、`dectype`中变量如果加了`()`那么返回的类型是引用类型。

3、auto是通过右值来判断的。