## 高性能服务器框架

- I/O处理单元。四种I/O模式，两种高校事件处理模式
- 逻辑单元。两种搞笑并发模式，有限状态机。
- 存储单元（本书不讨论）

### CS模型

- 启动后，创建一个或多个监听socket，并调用bind函数对其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。
- 稳定后，客户端可以调用connect向服务器发起连接了。由于客户端连接请求是随机到达的异步事件，服务器要用某种I/O模型来监听。经常使用select系统调用。
- 当监听到请求连接后，就调用accept函数接受它，并分配一个逻辑单元为新的连接服务（子进程，子线程）。
- 用fork分配子进程处理，处理好结果后返回给客户端。
- 若客户端主动关闭连接，则服务器执行被动关闭连接。

![image-20210228164954794](D:\桌面\推文\Linux高性能服务器编程\CS服务器模型.jpg)

- 优点：适合资源相对集中的场合。缺点访问量过大时，所有客户端得到很慢响应。

### 服务器编程框架

![image-20210228170339468](D:\桌面\推文\Linux高性能服务器编程\服务器编程框架.jpg)

| 模块         | 单个服务器程序             | 服务器集群                   |
| ------------ | -------------------------- | ---------------------------- |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库，文件或缓存     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间的永久TCP连接    |

- I/O处理单元是服务器管理客户连接的模块。等待并接受新客户连接，接受客户连接，将服务器响应数据返回给客户端。对服务器机群来说，I/O处理单元是一个专门的接入服务器。实现负载均衡。
- 一个逻辑单元通常是一个进程或者线程，它分析并处理客户数据，将结果传递给I/O处理单元或直接发送给客户端。对服务器机群来说，本身是一台逻辑服务器，拥有多个逻辑单元，实现多个客户任务的并行处理。
- 网络存储单元非必须。
- 请求队列是各单元之间的通信方式的抽象。

### IO模型

- IO复用：应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。有select、poll和epoll_wait。
- SIGIO信号可以用来报告I/O事件。

### 两种高效的事件处理模式

服务器经常要处理三种事件：I/O事件、信号和定时事件。

- Reactor模式

  - 要求主线程只监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程。除此之外，主线程不做其他实质性工作。读写数据，接受新连接，以及处理客户请求均在工作线程中完成。

  1. 主线程往epoll内核事件表中注册socket上的就绪事件。
  2. 主线程调用epoll_wait等待socket上有数据可读。
  3. 当socket上有数据可读时，epoll_wait通知主线程。主线程则将可读事件放入请求队列。
  4. 睡眠在请求队列上的某个工作线程被唤醒，从而socket读取数据，并处理客户请求，然后往epoll内核中注册socket上的写就绪事件。
  5. 主线程调用epoll_wait等待socket可写。
  6. 当socket可写时，epoll_wait通知主线程。主线程将socket写入事件放入请求队列。
  7. 睡眠在请求队列上的某个工作线程被唤醒，向socket上写入服务器处理客户请求的结果。

- Proactor模式

  - 所有I/O操作交给主线程和内核来处理，工作线程只负责业务逻辑，因此Proactor模式更符合服务器编程架构。

  1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。
  2. 主线程继续处理其他逻辑。
  3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，来通知应用程序数据已经可用。
  4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
  5. 主线程继续处理其他逻辑。
  6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，通知应用程序数据已经发送完毕。
  7. 应用程序预先定义好的信号。

### 两种高效的并发模式

在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行。“异步”指的是程序的执行需要由系统事件来驱动的。

- 半同步/半异步模式：同步线程用于处理客户逻辑（逻辑单元），异步线程用于处理I/O事件（I/O处理单元）。
  - 半同步/半反应堆模式：**缺点：**主线程和工作线程共享队列，主线程添加任务，工作线程取出任务，都需要对队列加锁保护，从而白白浪费CPU时间。每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度会越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU时间。
  - 优秀的情况下：主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程都接受之并将新返回连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。
- 领导者/追随者模式
  - 该模式是多个工作线程轮流获得事件源集合，轮流(监听、分发并处理事件)的一种模式。当领导者遇到新的I/O的时候要先挑选一个新领导者，新领导者继续监听而原来的处理事务。
  - 该模式有几个组件：句柄集，线程集，事件处理器，具体的事件处理器。
  - ![image-20210228215147975](D:\桌面\推文\Linux高性能服务器编程\领导者_追随者模式.jpg)
  - 句柄集：表示I/O资源，在Linux下通常就是一个文件描述符。
  - 线程集：该组件是所有工作线程
    - leader：线程当前处于领导者身份。
    - processing：线程正在处理事件。调用promote_new_leader方法推选新的领导者。
    - follower：追随者身份。调用线程集的join方法等待成为新的领导者。
    - ![image-20210228215556337](D:\桌面\推文\Linux高性能服务器编程\领导者_追随者模式1.jpg)
  - 事件处理器和具体的事件处理器：通常包含一个或多个回调函数handle_event，用于处理事件对应的业务逻辑。

