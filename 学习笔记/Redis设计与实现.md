[toc]

# Redis设计与实现

### 第二章 字符串

#### SDS是redis的默认字符串表示。

- SDS用含有`len,free`两个变量和一个字符串数组来表示，len表示已保存的字符串长度，free表示其中未使用的字节数量。
- 好处
  - 获取一个SDS的长度时间复杂度为O(1)
  - 拒绝缓存区溢出，当SDS的API要对SDS进行修改的时候，会先判断SDS的空间够不够，不够的话进行扩充，再接着执行。
  - 减少修改字符串时带来的内存重分配次数。
    - 空间预分配
      - 修改之后（len）的长度小于1MB，那么程序分配和len属性同样大小的未使用空间。
      - 假如长度大于1MB，那么程序会分配1MB的未使用空间。
    - 惰性释放空间
      - 当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收，而是使用free属性将这些字节的数量记录起来，并等待将来使用。
  - 二进制安全
    - 不在意写入数据是啥样的，怎么进去就怎么出来。所以SDS的buf被叫做字节数组。
  - 兼容C字符串函数
    - 会在分配字符串的时候再多分配一个字节来容纳这个空字符。

### 第三章 链表

#### 列表键的底层实现之一

### 第四章 字典

#### 数据库和 哈希键的底层实现之一

#### redis字典使用哈希表作为底层实现，一个哈希表里面有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值队。

- 哈希表结构体含有

  ```c++
  typedef struct dictht{
  	dictEntry **table;//每个元素指向一个键值对数组
  	unsigned long size;//哈希表大小
  	unsigned long sizemask;//等于size-1，和哈希值一起决定一个键应该放到哪个table数组上
  	unsigned long used;//目前已有节点数量。
  }dictht;
  ```

- 字典结构

  ```c++
  typedef struct dict{
  	dictType *type;//类型特定函数
  	void *privdata;//私有数据
  	dictht ht[2];//哈希表
  	int trehashidx;//
  }
  ```

  一般只使用`ht[0]`，`ht[1]`只会再对`ht[0]`进行`rehash`的使用

- hash冲突的时候，采用链地址法来解决键冲突，头插法。
- rehash
  - 首先，先对`ht[1]`分配空间，假如是要扩展hash就设置空间为`第一个大于等于ht[0].used*2的2^n`。假如是要缩小，就设置空间为`第一个大于等于ht[1].used得2^n` 
  - 之后将ht[0]得键值对rehash到ht[1]上。
  - 之后释放ht[0]，将ht[1]设置为ht[0]，并再ht[1]上创建一个空白哈希表。

- 渐进式rehash
  - 首先为ht[1]分配空间。
  - 在字典中维持一个索引计数器变量rehashidx，并将它设置为0，表示rehash工作正式开始。
  - 在进行期间，每次对字典添加，删除，查找和更新操作得时候，除了执行特定操作之外，还会将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]上面，当rehash工作完成后，将rehashidx属性+1。
  - 当rehash操作完成的时候，会将rehashidx设置为-1。
  - 好处，将rehash计算工作均摊到每个增删改查之上，避免了集中式rehash而带来的庞大计算量。

### 第五章 跳跃表

#### 有序集合键的底层实现之一

#### 跳跃表有点类似于ST表，对数据的操作是logN。

- 跳跃表按照分值排序，分层是用来加快访问速度的，而跨度是指到下一个节点的距离。后退节点。分值一样的情况下，按照成员对象在字典序中的大小进行排序。
- 跨度经常是不一样的。查找数据可以通过不同层进行一个跳跃。

### 第六章 整数集合

#### 是集合键的底层实现之一。

#### 其结构体含有编码方式（int16,int32,int64)，元素数量和元素数组

- 升级：将低编码转高编码。
  - 先扩充空间，然后从后面往前移动数据到对应位置。
  - 好处：提升灵活性，节约内存（在有必要的时候才升级）
- 降级：不支持

### 第七章 压缩列表

#### 是列表键和哈希键的底层实现之一。为了节约内存开发的顺序数据结构。

- 会产生连锁更新，遍历压缩列表的时候都是从后面开始遍历的，因此中间有一个叫`previous_entry_length`的属性，假如插入一个比较大的节点（大于等于254）该插入节点的下一个节点会发生变化。下一个节点变化了，该下一个节点的下一个节点的`previous_entry_length`也需要变更。
- 删除节点也可能发生连锁更新。
- 但是连锁更新的概率不会很大，就算发生了，只要影响的节点不多，也不会造成性能问题。

### 第八章 对象

#### 对象是将前面7章的内容结合起来的。

- redis采用引用技术的内存回收机制。
- 服务器初始化的时候会生成0到9999的字符串，之后只要用到就用引用技术。
- redis的类型多态和编码的多态。

### 第九章 数据库

#### redis中的所有内容都采用kv存储。

#### redis中的键过期是可以存放在一个expire字典里面的

- 可以通过expire key ttl设置过期时间。

#### 过期键有三个删除策略

- 定时删除，定时后对其进行键的删除操作。
  - 对内存友好，及时释放掉过期键内存。
  - 对cpu不友好，当过期键过多的情况会占用一部分cpu时间。
  - 创建定时器需要用redis服务中的时间事件，而当前时间事件的实现方式是无序链表，查询时间是O(N)，因此不太现实。
- 惰性删除，放任键过期不放，取的时候检查，如果过期就删除，没过期就返回该键。
  - 对cpu友好。
  - 对内存不友好
- 定期删除，每隔一段时间，程序对数据库检查一次，删除其过期键。
  - 对定时和惰性删除的折中方案。
  - 假如太频繁，退化为定时策略，cpu过多时间消耗在删除过期键上。
  - 假如太少，退化为惰性，浪费内存。

### 第十章 RDB持久化

- RDB持久化可以通过SAVE或者BGSAVE进行，也可以在配置文件中设置定时规则。SAVE使用的时候会阻塞，而BGSAVE是会另外开一个子进程进行的。
  - BGSAVE执行过程，SAVE会被服务器拒绝，BGSAVE会被服务器拒绝，两者都是怕发生竞争条件。
  - BGREWRITEAOF和BGSAVE不能同时进行
    - 假如BGSAVE正在执行，那么客户端发送的BGREWRITEAOF会被延迟到BGSAVE结束后执行。
    - 假如BGREWRITEAOF正在执行，那么BGSAVE会被服务器拒绝。
- RDB持久化的载入是在程序启动的时候发生的。
- 假如开启了AOP持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。除非AOP持久化关闭了，数据库才会使用RDB文件来还原数据库状态。载入过程会处于阻塞状态。

### 命令

`set k v`

`get k v`

`keys *`查询全部kv

`flushdb`清除当前数据库所有数据

`flushall`清除全部数据库的数据

`exists`判断当前位置存不存在

`move k db`在db数据库移除k键的kv

`expire k seconds`设置k键在seconds秒后过期

`ttl k`查看k的剩余时间

`type k`查看k的类型

### string

`incr`给改字符串+1

`decr`给字符串-1

`incrby k n`给字符串+ n

`decrby k n`给字符串- n

`strlen`查看字符串长度

`getrange k 0 3`获取字符串k，0到3之间包括3的字符串

`getrange k 0 -1`获取整个字符串

 `setrange k 0 xx`替换k中从0开始为xx

`setex(set with expire)`设置过期时间

`setnx(set if not exsit)`不存在就set，分布式锁中常常使用



