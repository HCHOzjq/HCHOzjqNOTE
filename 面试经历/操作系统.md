[TOC]

### 1、内核态和用户态的区别

- 内核态：CPU可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另外一个程序。
- 用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。
- 用户态如何陷入内核：系统调用，中断，异常。

### 2、线程和进程的区别(包括进程切换和线程切换的区别)

- 线程是cpu调度的基本单位，进程是资源分配的基本单位
- 一个系统可以有多个进程，一个进程可以有多个线程，且一个进程至少有一个线程。线程是进程的一部分，所以有时候线程被叫做轻量级进程。
- 一个进程崩溃不会影响到其他进程，一个线程崩溃则会影响到通一进程中的其他线程，会让其崩溃。
- 进程拥有独立的CPU资源（删）。线程可以访问进程中大部分内存空间，如数据段代码段，每个线程也只拥有一些再运行中的必不可少的私有属性。
- 进程通信主要是有管道，消息队列，共享内存等。而线程由于可以共享进程中的内存，所以线程通信可以是进程中的一段内存或者是信号量。也正是由于线程所用得资源共享，所以线程一般来说比进程更加高效。
- **进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB（快表）以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。**
- 进程有就绪阻塞和运行三种状态
- 进程和线程共享的资源包括
  - 进程代码段。
  - 进程的公共资源
  - 进程所拥有的资源。
- 线程独立的资源包括：
  - 线程ID：每个线程都有自己唯一的ID，用于区分不同的线程。
  - 寄存器组的值：当线程切换时，必须将原有的线程的寄存器集合的状态保存，以便重新切换时得以恢复。
  - 线程的堆栈：堆栈是保证线程独立运行所必须的。
  - 错误返回码：由于同一个进程中有很多个线程同时运行，可能某个线程进行系统调用后设置了error值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。
  - 线程优先级：线程调度的次序（并不是优先级大的一定会先执行，优先级大只是最先执行的机会大）。

### 4、线程中通信

- 互斥量，只有拥有互斥对象的线程才能访问公共资源的权限，因为互斥对象只有一个，所有可以保证公共资源不会被多个线程同时访问。
- 信号量，允许同一时刻多个线程访问同一资源，但需要控制同一时刻访问此资源的最大线程数量。
- 事件，通过通知操作的方式来保持多线程同步，还方便实现多线程优先级的比较操作。

### 5、进程通信

- 管道，主要分为：普通管道（无名，父子之间的），命名管道,消息队列，信号量，socket
- 管道是一种半双工的通信方式，只能单项流动，并且只能在具有亲缘关系的进程间流动，通常是父子关系。
- 命名管道也是半双工的通信方式，允许无亲缘关系的进程间通信，FIFO的文件形式存在。
- 信号量是一个计数器，控制多个进程对资源的访问，它通常作为一种锁机制。
- 消息队列是消息的链表，存放在内核中并由消息队列标识符表示。作用有：解耦可以将各种模块区分开来，异步让业务分散开来处理，削峰，先存入消息队列，然后慢慢处理，消息通讯，日志处理，不适合大文件拷贝。
- 信号是一种比较复杂的通信方式，由于通知接受进程某个事件已经发生。
- 共享内存就是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是能多个进程访问。

### 6、缓冲区溢出有什么危害

- 缓冲区溢出是指当计算机缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法的数据上。

- 程序崩溃，导致拒绝额外服务。
- 跳转并执行一段恶意代码。

### 7、锁的原因，什么是死锁

- 系统资源不足；
- 程序执行的顺序有问题；
- 资源分配不当等。

在多个并发进程中，如果每个进程持有某种资源而又等待其他进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称着一组进程产生了死锁。

### 8、页面置换算法

- 最佳页面置换算法
- 先进先出算法
- 最近最久未使用的置换算法（*LRU*）
- 时钟页面置换算法（*Lock*）把所有页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。
  - 当发生缺页中断时，算法首先检查表针指向的页面：
    - 如果它的访问位是0，就淘汰该页面，并把新的页面插入这个位置，然后把表针向前移一个位置。
    - 如果访问位是1就清除访问位，并把表针向前移一个位置，重复这个过程直到找到了一个访问位为0的页面就止。
- 最不常用置换算法（*LFU*）
  - 缺点：硬件成本高，且只考虑频率没考虑时间，如一些页面以前用的多，现在用的少，现在频繁访问的不是由于没有这些页面访问的次数高，在发生缺页中断时，就会可能误伤当前刚开始频繁访问，但访问次数还不高的页面。
  - 解决方法：定期减少访问的次数，当发生中断时，把过去时间访问页面的访问次数/2。

### 9、硬盘调度算法

- 先来先服务算法：访问的磁道可能会很分散，导致性能变差。
- 最短寻道时间优先算法：优先选择从当前磁头位置所需寻道时间最短的请求。这个算法可能存在一个饥饿现象，如一个动态请求，也就是磁道可能会在两个节点之间移动，导致很远处的地方没有寻道到。
- 扫描算法算法：在一个方向上跑，遇到最后磁道才换方向。
- 循环扫描算法：只扫描一个方向，复位的时候不读写数据回到原点，再接着跑。
- LOOK 与 C-LOOK 算法：左边的算法只需要移动到最远的请求，然后返回读取，右边移动到最远的请求，然后移动到另一边的最远请求。

### 10、进程调度算法

- 进程调度算法也叫CPU调度算法，因为进程是由CPU调度的。

- 进程调度有分抢占式和非抢占式调度。

- 先来先到服务调度算法（对长作业有利，适合CPU繁忙型IO，不适合I/O繁忙型IO

- 最短作业优先调度算法（优先选择运行时间最短的进程来运行，有利用提高系统的吞吐量，但是对长作业不利）

- 高响应比调度算法：权衡了短作业和长作业，每次调度的时候需要先计算响应比优先级，然后把响应比优先级最高的进程投入运行，响应比优先级的计算公式：

  - 优先权=（等待时间+要求服务时间）/要求服务时间
  - 从上面可只，如果两个进程等待时间相同的话，要求服务时间越短，其响应权越高，有利于短作业优先被选中运行
  - 如果两个进程要求服务时间相同时，等待时间越长，响应比就越高，兼顾了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高。

- 时间片轮转调度算法：最古老，最简单，最公平且使用最广的算法。时间片用完，进程还在运行，就会把该进程从CPU释放出来，并把CPU分配给另外一个进程，如果进程在时间片结束前阻塞或结束，则CPU立即进行切换。

  - 时间片太短会导致上下文切换频繁，降低了CPU效率
  - 时间片太长又可能引起短作业进程的响应时间变长。

- 最高优先级调度算法

  - 调度有优先级的，从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级调度算法。
  - 静态优先级：创建进程的时候，就已经确定了优先级了。
  - 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加则降低优先级，如果进程等待时间增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。
    - 非抢占式：当就绪队列中出现了优先级高的进程，运行完当前进程，再选择优先级高的
    - 抢占式：当就绪队列中出现了优先级高的进程，挂起当前进程，调度优先级高的进程运行。

- 多级反馈队列调度算法

  - 设置多个队列，优先级不一样，优先级越高时间片越少
  - 进程一进来，先放到优先级最高的队列上，在该队列上按照先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二队列的末尾。
  - 当较高级的队列为空，才调度较低优先级中的进程运行。如果进程运行时，有新的进程进入高优先级的队列，则停止当前运行的进程并将其移到原队列末尾，接着让高优先级的进程运行。

  最后，短作业会在高优先级的队列上运行结束，长作业虽然放到了低优先级上，但其时间片也变长了。

### 22、内存分配算法

- 首次适应算法：每次从前往后找适合的，该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。
- 最佳适应算法：每次都找最合适的一块，也就是大于等于要找的内存块的大小区域。该算法保留大的空闲区，但造成许多小的空闲区。该算法保留小的空闲区，尽量减少小的碎片产生。
- 最坏适应算法：每次都找最大的那块内存块去放。
- 伙伴算法：Linux


### 11、硬中断和软中断？？？

- 硬中断：外设中断
- 软中断：为了处理一些处理事件比较长的工作，放到中断之后来完成。
  - 区别
  - 软中断是执行中断指令发生的，而硬中断是由外设引发大的。
  - 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接给出，无需使用中断控制器。
  - 硬中断是可屏蔽的，软中断不可屏蔽。
  - 硬中断处理程序要确保它能快速完成任务，这样程序执行时才不会等待较长时间，称为上半部。
  - 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部分。

### 12、硬链接和软链接的区别

- 硬链接是指多个目录指向同一个文件。
- 软连接相当于重新创建一个文件。每个文件都有独立的inode，但这个文件的内容是另外一个文件的路径。
- 硬链接不可跨系统，软链接可跨系统。
- 硬链接需要全部的链接都删除才能删除，软连接如果目标文件被删除了，就会找不到目标文件。

### 13、缓冲和非缓冲I/O

- 把是否利用标准库缓冲作为区分缓冲I/O和非缓冲I/O的标志。
- 缓冲I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。
- 非缓冲I/O是系统直接通过系统调用访问文件，不经过标准库缓存。
- 所谓的缓冲是标准库内部实现的缓冲。

### 14、直接和非直接I/O

- 把是否利用操作系统的缓存作为区分直接I/O和非直接I/O的评判标准。
- 非直接I/O什么时候会写入磁盘
  - 当缓存区满了的时候，
  - 用户主动调用sync，内核缓存会刷到磁盘上。
  - 当内存十分紧张，无法再分配页面时。
  - 内核缓存的数据缓存时间超过某个时间时，也会把数据刷到磁盘上。

### 15、阻塞与非阻塞I/O vs 同步与异步I/O

- 阻塞就是你去请求的时候不会立即返回，而非阻塞就是你去请求无论结果如何都会返回。
- 非阻塞I/O的多路复用例如select，当数据准备好之后就可以将该数据放到内核区域上，并且通知进程去处理。
- 无论是阻塞或非阻塞I/O，他们的过程都是同步调用，因为在read调用的时候，内核都将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待比较长的时间。
- 而异步I/O是aio_read的情况。

### 16、进程同步方法

- 信号量：信号量本身无法传递数据，配合共享内存使用，类似于线程中的锁，用于保护临界资源。
- 管道，只局限于父子进程。
- 信号，进程间传递信号，捕获到信号后执行对应的代码。
- 消息队列：也是非常常见的同步方式，把数据放入队列，内核逐一处理发送至目的线程。
- socket：

### 17、进程同步机制

- 让权等待：当进程不能进入自己的临界区时，应该立即释放处理器，以免陷入“忙等”。（sleep())
- 忙着等待：当进程想要获取被占用的资源的时候，这时候会忙则等待。
- 有限等待：确保该进程在有效时间内进入自己的临界区，以避免死等。
- 空闲让进：当无进程处于临界区时，临界区处于空闲状态，进程可进。

### 18、僵尸进程

- 父进程不回收子进程的进程控制块，就会产生僵尸进程。
- 解决方法是用wait命令·回收子进程的pcb。或者是直接kill掉其父进程，让僵尸进程变为init进程的子进程，而init进程本身会循环wait去回收每个子进程

### 19、孤儿进程

- 父进程被kill了，但是孤儿进程会被init所接管，所以孤儿进程一般没啥危害。

### 19、生产者消费者

```C++
/*生产者进程结构：*/
do{  
     wait(empty) ;  
     wait(mutex) ;  
      
     add nextp to buffer  
      
     signal(mutex) ;  
     signal(full) ;  
}while(1) ;
 
/*消费者进程结构：*/
do{  
     wait(full) ;  
     wait(mutex) ;  
      
     remove an item from buffer to nextp  
      
     signal(mutex) ;  
     signal(empty) ;  
}while(1) ;
```

### 20、读者写者问题

![image-20210325154730351](C:\Users\zjq\AppData\Roaming\Typora\typora-user-images\image-20210325154730351.png)

### 21、虚拟内存的好处

- 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系。（把脏活累活丢该内核去做）
- 当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存。（写时复制）
- 在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存。（充分利用物理空间）

### 22、用户级线程和系统级线程

- 用户级线程不需要依赖系统，而系统级线程需要依赖系统，如创建，销毁，切换等操作，用户级线程比较简单。
- 用户级线程只能在用户态上运行，而系统级可以在任何状态上运行。
- 用户级线程系统调用的时候，会阻塞该线程对应的进程，系统级系统调用时，不会阻塞该进程。
- 对于一个进程中的用户级线程，只能有一个被执行，而系统级的线程里，能有多个线程并发进行。
- 系统级线程只要很小的数据结构和堆栈，切换速度快，但是系统级的线程切换需要从用户态和内核态之间的切换，比较占用资源。。

### 23、分段的好坏处

- 能申请一段连续的内存。

- 内存碎片比较多。
- 内存交换效率低的问题，每次交换都需要写一大段内存。

### 24、分页的好处

- 解决了内存碎片的问题，因为其内存空间都是预先划分好的。
- 解决了交换效率低的问题，每次交换只需要交换那一些需要用到的内容。（换入换出）
- 一级页表和二级页表
- 二级页表更加节约空间，可以利用局部性原理只存放一级页表以及一部分的二级页表（需要用到的地方），快表

### 25、Linux中的内存管理

- Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。
- 32位的操作系统中，内核空间占1G，剩下3G都是用户空间。

### 26、零拷贝

- 不需要经过CPU操作的拷贝
- 只需要将数磁盘数据拷贝到缓存区中，再将缓冲区的内容直接考到网卡上

### 27、Linux命令

- top查看cpu，内存等负载。
- free查看内存使用情况。
- du，df用来查看磁盘使用情况，前者查看的是当前存在的，没有被删除的。后者能看到已经删除的文件。

- tcpdump：用来查看网络情况，nc用来连接一个socket