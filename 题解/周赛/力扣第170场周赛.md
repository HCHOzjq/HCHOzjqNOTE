### 第一题

给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符：

字符（'a' - 'i'）分别用（'1' - '9'）表示。
字符（'j' - 'z'）分别用（'10#' - '26#'）表示。 
返回映射之后形成的新字符串。

题目数据保证映射始终唯一。

> 示例 1：
>
> 输入：s = "10#11#12"
> 输出："jkab"
> 解释："j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".

__题解__：比赛的时候想的有点复杂，瞎写了几十行，wa了几次。。。最后才写成了下面这个样子D:

题意如上。当我们遇到当前字符+2为‘#’的时候，我们就需要特殊的处理，用一个`while`循环来对剩下两个字符累加最后映射出来。其他情况，我们都按单个字符处理。

```c++
    string freqAlphabets(string s) {
        string ans;
        for(int i=0;i<s.length();i++){
            if(i+2<s.length()&&s[i+2]=='#'){
                int end=i+2;
                int t=0;
                while(i<end){
                    t=t*10+s[i++]-'0';
                }
                
                ans+=t+'a'-1;
            }else {
                ans+=s[i]+'a'-'0'-1;
            }
        }
        return ans;
    }
```

### 第二题

这题目有三种写法：暴力，前缀和，线段树。

我用的是暴力，虽然一开始是有想到前缀和，，算出来的结果是正确的。但是我把答案以为是第二个样例。结果还是暴力了一波过了23333。

线段树是队友写的，赛后我也补了补。

讲一下前缀和吧：如果不懂，emm百度一下前缀和hhh。

在想要怎么讲清楚这道题，想到那么个例子：

A^B=C类比于001^000=110。

那反过来C^A=B有110^001=000。好像计算机的减法就是这样子来的。

这样子岂不是满足加法的形式A+B=C同时C-A=B。那就套用前缀和就ok啦。

暴力：

```C++
int a[30005];
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int> ans;
       
        for(int i=0;i<queries.size();i++){
            int x=queries[i][0],y=queries[i][1];
            int z=arr[x];
            for(int j=x+1;j<=y;j++){
                z^=arr[j];
            }
            ans.push_back(z);
        }
        return ans;
    }
```

前缀和：（贴上来的是周赛第二的dalao的代码，懒得写了hhh）

```C++
vector<int> xorQueries(vector<int>& a, vector<vector<int>>& queries) {
        int n = a.size();
        vector<int> s(n+1);
        for (int i = 0; i < n; ++ i)
        {
            s[i+1] = s[i]^a[i];
        }
        vector<int> ret;
        for (auto e : queries)
        {
            int x = e[0]+1, y = e[1]+1;
            ret.push_back(s[y]^s[x-1]);
        }
        return ret;
    }
```

线段树：感兴趣可以学习这个数据结构。主要的功能就是区间的一些操作。时间复杂度平均每次`O(lonn)`

```C++
vector<int> a;
    struct node
    {
        int l,r,val;
    }no[30005<<2];
    void build(int v,int l,int r){
        no[v].l=l;no[v].r=r;
        if(l==r){
            no[v].val=a[l];
            return ;
        }
        int mid=(l+r)>>1;
        build(v<<1,l,mid);
        build(v<<1|1,mid+1,r);
        no[v].val=no[v<<1].val^no[v<<1|1].val;
    }
    int query(int v,int l,int r)
    {
        int ll=no[v].l,rr=no[v].r;
        if(ll==l&&rr==r){
            return no[v].val;
        }
        int mid=(ll+rr)>>1;
        if(mid>=r){
            return query(v<<1,l,r);
        }else if(mid<l){
            return query(v<<1|1,l,r);
        }else {
            return query(v<<1,l,mid)^query(v<<1|1,mid+1,r);
        }
    }
    
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        a=arr;
        build(1,0,arr.size()-1);
        vector<int> ans;
        for(int i=0;i<queries.size();i++){
            int x=queries[i][0],y=queries[i][1];
            ans.push_back(query(1,x,y));
        }
        return ans;
    }
```

### 第四题

动态规划求最长回文串，也可以用下马拉车算法（可以线性），感兴趣可以学学，这里就先不讲~

用的是二维的数字，先把字符串反过来，然后。

如果`S[i]==tmp[j]`有`num[i][j]=num[i-1][j-1]+1;`

如果`S[i]!=tmp[j]`有`num[i][j]=max(num[i-1][j],num[i][j-1]);`

```C++
int num[505][505];
    int minInsertions(string s) {
        int n=s.length();
        string tmp=s;reverse(s.begin(),s.end());
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(s[i-1]==tmp[j-1]){
                    num[i][j]=num[i-1][j-1]+1;
                }else {
                    num[i][j]=max(num[i-1][j],num[i][j-1]);
                }
            }
        }
        return n-num[n][n];
    }
```