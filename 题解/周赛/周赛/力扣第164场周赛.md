### 第一题

A 和 B 在一个 3 x 3 的网格上玩井字棋。

井字棋游戏的规则如下：

玩家轮流将棋子放在空方格 (" ") 上。第一个玩家 A 总是用 "X" 作为棋子，而第二个玩家 B 总是用 "O" 作为棋子。"X" 和 "O" 只能放在空方格中，而不能放在已经被占用的方格上。只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。如果所有方块都放满棋子（不为空），游戏也会结束。游戏结束后，棋子无法再进行任何移动。

给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。

如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。

#### 示例 1：

> 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
> 输出："A"
> 解释："A" 获胜，他总是先走。
> "X  "    "X  "    "X  "    "X  "    "X  "
> "   " -> "   " -> " X " -> " X " -> " X "
> "   "    "O  "    "O  "    "OO "    "OOX"

思路：模拟+循环判断，写循环要吐2333

按着moves所走，所以每走一步判断有没有人赢，用1表示A走，2表示B走。每步判断一下就好了。

```c++
class Solution {
public:
    vector<vector<int>> tu;
    bool win1()
    {
        int t=tu[0][0];
        int ans=0;
        if(t!=0)
        for(int i=0;i<3;i++){if(tu[i][i]==t)ans++;}
        if(ans==3)return true;ans=0;
        t=tu[2][0];
        if(t!=0)
        for(int i=2;i>=0;i--){if(tu[i][2-i]==t)ans++;}
        if(ans==3)return true;
        for(int i=0;i<3;i++){
            ans=0;t=tu[i][0];
            if(t!=0)for(int j=0;j<3;j++){if(tu[i][j]==t)ans++;}
            if(ans==3)return true;
        }
        for(int i=0;i<3;i++){
            ans=0;t=tu[0][i];
            if(t!=0)for(int j=0;j<3;j++){if(t==tu[j][i])ans++;
            }
            if(ans==3)return true;
        }
        return false;
    }
   
    string tictactoe(vector<vector<int>>& moves) {
        vector<int> t(3);tu.push_back(t);tu.push_back(t);tu.push_back(t);
        for(int i=0;i<moves.size();i++)
        {
            if(i%2==0)tu[moves[i][0]][moves[i][1]]=1;
            else tu[moves[i][0]][moves[i][1]]=2;
            if(win1()){return i%2==0?"A":"B";}
        }
        int flag=0;
        for(int i=0;i<3;i++)for(int j=0;j<3;j++){
                if(tu[i][j]==0)flag=1;
        }
        if(flag)return "Pending";
        else return "Draw";
    }
};
```

### 第二题

圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：

巨无霸汉堡：4 片番茄和 1 片奶酪
小皇堡：2 片番茄和 1 片奶酪

请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。

#### 示例 1：

> 输入：tomatoSlices = 16, cheeseSlices = 7
> 输出：[1,6]
> 解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。

题解：初中数学题目

设巨无霸汉堡为x个，小皇堡为y个。有`4*x+2*y=番茄个数`，`1*x+1*y=奶酪个数`。求x和y，不就是求解方程组嘛。草稿纸推推，求出公式就可以了。

```C++
class Solution {
public:
    vector<int> numOfBurgers(int t, int c) {
        int x=(t-2*c)/2;
        int y=(t-4*x)/2;
        
        vector<int> ans;
        if(x*4+2*y!=t||x+y!=c||x<0||y<0){
            return ans;
        }else {
            ans.push_back(x);ans.push_back(y);
        }return ans;
    }
};
```

### 第三题

给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。

#### 示例 1：

 >输入：matrix =
 >[
 >  [0,1,1,1],
 >  [1,1,1,1],
 >  [0,1,1,1]
 >]
 >输出：15
 >解释： 
 >边长为 1 的正方形有 10 个。
 >边长为 2 的正方形有 4 个。
 >边长为 3 的正方形有 1 个。
 >正方形的总数 = 10 + 4 + 1 = 15.

题解：二维前缀和+暴力。

先简单讲讲一维的前缀和。一个简单的公式`sum[i]=sum[i-1]+a[i]` 这是一位前缀和，sum[i]为1到i的元素之和。那么我们求每个数字的时候，就有`sum[i]-sum[i-1]=a[i]`。前缀和一般用在优化上。如那些需要遍历a到b的情况有`sum[a]-sum[b-1]`为什么是`b-1`，因为`sum[b-1]`没有包括`a[b]`。

那么同样的道理，二维前缀和就等于__左下前缀和+这个点上方的前缀和+本身-左上前缀和__。如果有不同，可以现在动手百度一下二维前缀和。蛮简单的。看看图就懂了~



![在这里插入图片描述](https://img-blog.csdn.net/20180921215152309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTkwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

详细讲一下，__左上前缀和是红色，左下前缀和是红色+蓝色，这个点上方前缀和是绿色+红色。__

求整个的面积可以用__紫色+蓝色红色+红色绿色-红色__。

那么就有`sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][i-1]`

我们先求每个点的二维前缀和，小小模拟一下下，向右向下延长正方形的边，判断边*边是不是等于中间的`sum值`为`sum[i][j]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1]`。

### 第四题

给你一个由小写字母组成的字符串 s，和一个整数 k。

请你按下面的要求分割字符串：

首先，你可以将 s 中的部分字符修改为其他的小写英文字母。
接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。
请返回以这种方式分割字符串所需修改的最少字符数。

> 示例 1：
>
> 输入：s = "abc", k = 2
> 输出：1
> 解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。
> 示例 2：
>
> 输入：s = "aabbc", k = 3
> 输出：0
> 解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。
> 示例 3：
>
> 输入：s = "leetcode", k = 8
> 输出：0

就放下题面吧哈哈

```
class Solution {
public:
    string str;
  
    int dp[200][200][200];
    int palindromePartition(string s, int v) {
        str=s;
        for (int i=0; i<s.length(); ++i) {
            for (int j=0; j<s.length(); ++j) {
                for (int t=2; t<=v; ++t) dp[i][j][t]=0x3f3f3f3f;
            }
        }
        for(int i=0;i<s.length();i++){
            for(int j=i-1;j>=0;j--){
                
                if(str[i]==str[j])dp[j][i][1]=dp[j+1][i-1][1];
                else dp[j][i][1]=dp[j+1][i-1][1]+1;
                
                for(int k=j;k<i;k++){
                    for(int l=2;l<=v&&l-1<=k-j+1;l++){
                        dp[j][i][l]=min(dp[j][i][l],dp[j][k][l-1]+dp[k+1][i][1]);
                    }
                }
            }
        }
        return dp[0][s.length()-1][v];
    }
};
```

