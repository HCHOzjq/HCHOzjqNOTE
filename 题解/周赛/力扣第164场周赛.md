> 前言：昨天早上跑1km跑完回宿舍就10：30了，挂了半条命。最后是在赛后写了题，所以咕咕咕。今天才编辑好。

### 第一题

平面上有 n 个点，点的位置用整数坐标表示 `points[i] = [xi, yi]`。请你计算访问所有这些点需要的最小时间（以秒为单位）。

你可以按照下面的规则在平面上移动：

- 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。
- 必须按照数组中出现的顺序来访问这些点。

**示例 1：** 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png)

> 输入：points = [[1,1],[3,4],[-1,0]]
> 输出：7
> 解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0] 
> 从 [1,1] 到 [3,4] 需要 3 秒 
> 从 [3,4] 到 [-1,0] 需要 4 秒
> 一共需要 7 秒

题解：
这道题蛮简单的，从第一个点出发，你可以水平移动和竖直方向移动或者对角线移动，而且题目有一个很舒服的地方就是必须按着题目给的顺序计算。所以就不用排序了。直接对每个点与前面一个点进行比较，因为可以对角线走。那么：对于两点的横坐标之差和纵坐标之差取较小值就是对角线走的次数，剩下的用两者最大值减去这个对角线走的次数就可以了。其实也可以直接求横纵坐标的最大值去相加来求得，但是理解起来不怎么直观。

### 第二题

这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。

- 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。

- 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。

 **示例 1：** 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg)

> 输入：grid = [[1,0],[0,1]]
> 输出：0
> 解释：没有一台服务器能与其他服务器进行通信。

暴力+技巧
技巧是如何简单判断该行列两个电脑可以连接，用两个数组。一个用来计算每行中的计算机个数，另一个计算每列中的计算机个数。
先遍历一次二维数组，每个计算机所在的行列要进行+1的操作。之后再遍历一次，判断存在该计算机所在行或者列中计算机个数是不是大于等于2。为什么要大于等于二，因为只有大于等于二才有两个计算机相连。



### 第三题

给你一个产品数组 `products` 和一个字符串 `searchWord` ，`products` 数组中每个产品都是一个字符串。

- 请你设计一个推荐系统，在依次输入单词 `searchWord` 的每一个字母后，推荐 `products` 数组中前缀与 `searchWord` 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。

**示例 1：**

> 输入：products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
> 输出：[
> ["mobile","moneypot","monitor"],
> ["mobile","moneypot","monitor"],
> ["mouse","mousepad"],
> ["mouse","mousepad"],
> ["mouse","mousepad"]
> ]
> 解释：按字典序排序后的产品列表是 ["mobile","moneypot","monitor","mouse","mousepad"]
> 输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 ["mobile","moneypot","monitor"]
> 输入 mou， mous 和 mouse 后系统都返回 ["mouse","mousepad"]
> 请你以二维列表的形式，返回在输入 `searchWord` 每个字母后相应的推荐产品的列表。

暴力，别问，问就是不会`Trie`树(不过也差不多要学到了)
首先有一个函数，来计算一个单词的前缀。之后用一个字符串来存`searchWord`的前缀。

遍历products数组，求每个数组的前缀，如果该前缀与`searchWord`的前缀一样，那么可以对接下来的单词进行判断了，求前缀，判断前缀。

我用了一个`pos`来表示`searchWord`前缀第一个匹配的单词位置，防止超时。由于只需要前三个单词，所以用了个`z`来计数。注意的是如果在`searchWord`的前k前缀中没有匹配到单词，我们就需要直接推一个空的`vector`进去。

### 第四题

有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。

每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。

- 给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。

- 由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

**示例 1：**

> 输入：steps = 3, arrLen = 2
> 输出：4
> 解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
> 向右，向左，不动
> 不动，向右，向左
> 向右，不动，向左
> 不动，不动，不动

第一个，每个位置都可以由该位置或者前面一个位置或者后面一个位置走来。DP的一个特点前面的会影响后面的，后面的影响不了前面的。

第二个，数组其实不用开到1000000去，因为`steps`最大是500所以最远只可以走到500.。

第三个需要两个数组，一个用来存前一步的所有状态，一个用来计算现在的。