### 第一题	统计位数为偶数的数字

> 比赛链接：https://leetcode-cn.com/contest/weekly-contest-168/

给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。

> 示例 1：
>
> 输入：nums = [12,345,2,6,7896]
> 输出：2
> 解释：
> 12 是 2 位数字（位数为偶数） 
> 345 是 3 位数字（位数为奇数）  
> 2 是 1 位数字（位数为奇数） 
> 6 是 1 位数字 位数为奇数） 
> 7896 是 4 位数字（位数为偶数）  
> 因此只有 12 和 7896 是位数为偶数的数字

__题解：暴力不解释（：__

```
    bool ok(int x)
    {
        int ans=0;
        while(x){
            x/=10;
            ans++;
        }
        return ans%2==0;
    }
    
    int findNumbers(vector<int>& nums) {
        int ans=0;
        for(int i=0;i<nums.size();i++){
            if(ok(nums[i]))ans++;
        }
        return ans;
    }
```

### 第二题	划分数组为连续数字的集合

给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。
如果可以，请返回 True；否则，返回 False。

> 示例 1：
>
> 输入：nums = [1,2,3,3,4,4,5,6], k = 4
> 输出：true
> 解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。

__题解：如题，可以被划分成由k个连续数字组成对的集合。重点是连续，我们可以先得到每个数字有多少个，然后每次取最小的且还有剩余的那个数字`i`，对`i`到`i+k-1`的数字进行减1的操作。例如`122334`我们第一次减的是`123`第二次减的是`234`。因为减去第一次后，第二次中1没法再用了。__

```
bool isPossibleDivide(vector<int>& nums, int k) {
        if(nums.size()%k)return 0;
        sort(nums.begin(),nums.end());
        map<int,int> m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        for(int i=0;i<nums.size();i++){
            if(m[nums[i]]){
                for(int j=0;j<k;j++){
                    if(m[nums[i]+j]==0)return false;
                    m[nums[i]+j]--;
                }
            }
        }
        return true;
    }
```

### 第三题	子串的最大出现次数

给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：

子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。

> 示例 1：
>
> 输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
> 输出：2
> 解释：子串 "aab" 在原字符串中出现了 2 次。
> 它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。

__题解：__

__技巧之一：substr的运用，str.substr(i,len)，返回str字符串中从第i到i+len-1的子串__

__技巧之二：inline内联函数的运用，减少运行时间，好像不多__

__技巧之三：auto的运用，就是按着=号右边的变量类型声明一个变量__

思路，感觉是被`minSize`和`maxSize`给骗了。如过出现`ab`和`abb`这两个子串，可以知道`abb`出现过的话`ab`肯定也出现过。所以我们计算只需要计算`minSize`。遍历一次字符串，选取初始字母，再遍历选取长度。用一个`get`函数求得该子串的字母数量。用`map<string,int>`储存每个子串出现的次数。最后`auto`跑一遍迭代器。能看到这的，不懂迭代器的话，可以把它看成指针。

```
int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
       int ans=0;
        map<string,int> m;
        for(int len=minSize;len<=minSize;len++){
            for(int i=0;i<s.length()-len+1;i++){
                string str=s.substr(i,len);
                if(get(str)<=maxLetters){
                    m[str]++;
                }
            }
        }
        for(auto it=m.begin();it!=m.end();it++){
            ans=max(ans,it->second);
        }
        return ans;
    }
    inline int get(string s)
    {
        int cnt=0;
        set<char> m;
        for(int i=0;i<s.length();i++){
            m.insert(s[i]);
        }
        return m.size();
    }
```

### 第四题	你能从盒子里获得的最大糖果数

给你 n 个盒子，每个盒子的格式为 [status, candies, keys, containedBoxes] ，其中：

状态字 status[i]：整数，如果 box[i] 是开的，那么是 1 ，否则是 0 。
糖果数 candies[i]: 整数，表示 box[i] 中糖果的数目。
钥匙 keys[i]：数组，表示你打开 box[i] 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。
内含的盒子 containedBoxes[i]：整数，表示放在 box[i] 里的盒子所对应的下标。
给你一个 initialBoxes 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。

请你按照上述规则，返回可以获得糖果的 最大数目 。

> 示例 1：
>
> 输入：status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
> 输出：16
> 解释：
> 一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。
> 盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。
> 在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。
> 你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。

思路很简单，但难搞，情况多，能看到这就不需要我解释了吧，小声bb。

其实是用一个`queue`存一下，目前可开的。用另外一个存现在可以开中可以找到的盒子，拿出里面所有的钥匙和盒子。有钥匙的用一个标记数组标记，盒子就放到一个queue里面，然后逐步判断拿出来的盒子能不能被钥匙打开，可以就放到`que3`里面

