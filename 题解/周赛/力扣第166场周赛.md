周赛链接：

### 第一题

给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

示例 1：

>输入：n = 234
>输出：15 
>解释：
>各位数之积 = 2 * 3 * 4 = 24 
>各位数之和 = 2 + 3 + 4 = 9 
>结果 = 24 - 9 = 15

题解：直接看代码吧，签到题。刚学程序语言的可以研究一下下。

```
class Solution {
public:
    int subtractProductAndSum(int n) {
        int j,h;
        j=1;h=0;
        while(n>0){
            j*=n%10;
            h+=n%10;n/=10;
        }
        return j-h;
    }
};
```

### 第二题

有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。

你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。

示例 1：

 >输入：groupSizes = [3,3,3,3,3,1,3]
 >输出：[[5],[0,1,2],[3,4,6]]
 >解释： 
 >其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。

题解：看数据量很少。周赛暴力过的，用一个book数组判断有没有用过这个数字，然后再添加等同于这个数字的数字数量到一个vector里面。

```C++
vector<vector<int>> groupThePeople(vector<int>& g) {
        int book[600]={0};
        vector<vector<int> > ans;
        while(true)
        {
            int f=0;int tim,tmp;
         for(int i=0;i<g.size();i++){
            if(book[i]==0){
                tim=tmp=g[i];f=1;
            }
        }  
            if(f==0)break;
            vector<int> a;
            for(int i=0;i<g.size();i++){
                if(g[i]==tmp&&book[i]==0&&tim){
                    tim--;
                    book[i]=1;
                    a.push_back(i);
                }
            }
            ans.push_back(a);
        }
        return ans;
    }
```

之后看到别人写的，感觉自己智商降维了。。这种做法就直接用一个vector数组，每个元素下标表示是那个数字，之后添加到vector里面，到了数量push_back到大数组里，再清空。

```C++
class Solution {
public:
    vector<int> G[505];
    vector<vector<int>> groupThePeople(vector<int>& g) {
        vector<vector<int>>ans;
        for (int i=0; i<g.size(); ++i) {
            int t=g[i];
            G[t].push_back(i);
            if (G[t].size()==t) ans.push_back(G[t]),G[t].clear();
        }
        return ans;
    }
};
```

### 第三题

给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。

请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。

每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。

题目保证一定有解。

示例 1：

> 输入：nums = [1,2,5,9], threshold = 6
> 输出：5
> 解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
> 如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。

题解：数据很大，二分。然后判断。向上取整要注意一下下。当超过闸值的时候，说明除数太小，那么l=mid+1。没超过就满足除数大了或者刚刚好，r=mid。

```C++
class Solution {
public:
    int sum(vector<int> n,int t)
    {
        int ans=0;
        for(int i=0;i<n.size();i++){
            ans=ans+n[i]/t+((n[i]%t)?1:0);
        }
        return ans;
    }
    int smallestDivisor(vector<int>& nums, int t) {
        int l=1,r=0x3f3f3f3f;
        while(l<r){
            int mid=l+(r-l)/2;
            int c=sum(nums,mid);
            if(c>t)l=mid+1;
            else r=mid;
        }
        return l;
    }
};
```

### 第四题

给你一个 m x n 的二进制矩阵 mat。

每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。（注：相邻的两个单元格共享同一条边。）

请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。

二进制矩阵的每一个格子要么是 0 要么是 1 。

全零矩阵是所有格子都为 0 的矩阵。

示例 1：

![img](https://assets.leetcode.com/uploads/2019/11/28/matrix.png)

> 输入：mat = [[0,0],[0,1]]
> 输出：3
> 解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。

题解：dfs还是bfs，比赛的时候用的是dfs，卡了23333。赛后向bfs低头了，求到达某个状态的最小值。先跑一次bfs求出达到某个状态的最小步数。有亮点的是`map<vector<int,int>,int>`的运用，平时用的比较少。

```C++
class Solution {
public:
   map<vector<vector<int> >,int> mm;
int m,n;
    vector<vector<int> > change(vector<vector<int> > &tu,int x,int y)
    {
        vector<vector<int> > tmp=tu;
        if(x>0)tmp[x-1][y]=1-tu[x-1][y];
        if(x<m-1)tmp[x+1][y]=1-tu[x+1][y];
        if(y>0)tmp[x][y-1]=1-tu[x][y-1];
        if(y<n-1)tmp[x][y+1]=1-tu[x][y+1];
        tmp[x][y]=1-tu[x][y];
        return tmp;
    }
    void bfs(vector<vector<int> > tu)
    {
        //if(mm.count(tu))return ;c
        queue<vector<vector<int> > > que;
        que.push(tu);
        mm[tu]=0;
        while(!que.empty()){
            vector<vector<int> > u=que.front();que.pop();
            for(int i=0;i<tu.size();i++){
            for(int j=0;j<tu[i].size();j++){
                vector<vector<int> > tmp=change(u,i,j);
                if(mm.count(tmp)){continue;}
                mm[tmp]=mm[u]+1;
                que.push(tmp);
            }
        }
        }
    }
    
    int minFlips(vector<vector<int> >& mat) {
       vector<vector<int> > mmm=mat;
        m=mat.size(),n=mat[0].size();
        for(int i=0;i<mmm.size();i++){
            for(int j=0;j<mmm[0].size();j++){
                mmm[i][j]=0;
            }
        }
        bfs(mmm);
        if(mm.count(mat))return mm[mat];else return -1;
    }
};
```

