### 第一题

给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 十进制值 。

> 输入：head = [1,0,1]
> 输出：5
> 解释：二进制数 (101) 转化为十进制数 (5)

题解：理解了链表这道题其实就是一个链表的遍历操作。二进制的计算方法其实就是`ans=ans*2+now`

ans是答案，now就是当且二进制位的值。要从左遍历到右。链表也是，所以简单敲出答案。

```
int getDecimalValue(ListNode* head) {
        int ans=0;
        while(head!=NULL){
            ans=ans*2+head->val;
            head=head->next;
        }return ans;
    }
```

### 第二题

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

> 示例 1：
>
> 输出：low = 100, high = 300
> 输出：[123,234]

题解：暴力模拟&打表，首先我们得构造出一个模板如`123`和一个累加值`111`。有了这两个变量后，我们要判断累加后是不是在`low`和`high`之间。是我们就存进去。当个数为9的时候，得再次构造一次模板和累加值，也就是位数+1，如`1234`和`1111`。这样子就很清晰了。当最终位数达到九位数且个位为9的时候，我们就退出遍历。

```
vector<int> sequentialDigits(int low, int high) {
        int ll=0;
        int lll=low;
        while(lll>0){//用来计算有几位数
            lll/=10;
            ll++;
        }
        int first=0;
        int tmp=0;
        for(int i=1;i<=ll;i++){//用来计算一开始的模板和累加值
            first=first*10+i;
            tmp=tmp*10+1;
        }
        int now=first;
        vector<int> ans;
        while(now<=high){
            if(now>=low)ans.push_back(now);
            if(now%10==9){//更新模板累加值和位数
                first=first*10+(ll+1);
                if(ll+1==10)break;
                tmp=tmp*10+1;
                now=first;
                ll++;continue;
            }
            now+=tmp;
        }return ans;
    }
```

再贴一下第一名的代码，可以借鉴借鉴：i表示的是多少位数，j表示的是第一个数字是什么，k就累加到一个数字。

```
vector<int> sequentialDigits(int low, int high) {
        vector<int> ans;
        for (int i = 1; i <= 9; ++i) {
            for (int j = 1; j + i - 1 <= 9; ++j) {
                int x = 0;
                for (int k = 0; k < i; ++k)
                    x = x * 10 + (k + j);
                if (low <= x && x <= high)
                    ans.push_back(x);
            }
        }
        return ans;
    }
```



### 第三题

给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。

请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。


示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/e1.png)

> 输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
> 输出：2
> 解释：总和小于 4 的正方形的最大边长为 2，如图所示。

题解：如果读者看过我之前发的题解的话。在第165场周赛有一道题和这题目类似，那题是求：矩阵中完全由 1 组成的 正方形 子矩阵的个数。这题就相对简单一些，那道题我们用的是二维前缀和来优化，同理这题也可以用二维前缀和，先求得每个点的二维前缀和如何枚举每个点所可以到达左上点的最大矩阵长度就可以了。

```
int dp[500][500];
    int maxSideLength(vector<vector<int>>& mat, int t) {
        memset(dp,0,sizeof dp);
        for(int i=1;i<=mat.size();i++){
            for(int j=1;j<=mat[0].size();j++){
                dp[i][j]=mat[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];
            }
        }
        int ans=-1; 
        for(int i=1;i<=mat.size();i++){
            for(int j=1;j<=mat[0].size();j++){ 
                for(int len=1;len<=min(i,j);len++){//枚举可以到达的最大矩阵。
                    if(dp[i][j]-dp[i-len][j]-dp[i][j-len]+dp[i-len][j-len]<=t){
                        ans=max(len,ans);
                    }
                }
            }
        }
       
        if(ans==-1)return 0;
        else return ans;
    }
```

### 第四题

给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。

如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。

> 示例 1：
>
> 输入： 
> grid = 
> [[0,0,0],
>  [1,1,0],
>  [0,0,0],
>  [0,1,1],
>  [0,0,0]], 
> k = 1
> 输出：6
>
> 解释：
> 不消除任何障碍的最短路径是 10。消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).

题解：dfs+剪枝（不严谨但可以过）&三维数组

如何剪枝呢？我们dfs遇到障碍物我们可消除的就减1，当可消除为0的时候，我们肯定不能继续走下去了，剪枝+1。我们知道，当没有障碍物的时候，我们最短的路径一定是n+m-1，第二个当我们dfs的时候求得最短的路径时就用一个标记的变量说明我们已经找到最小的值了，无论接下去怎么找其他都没法比这个更短的了，这个时候我们就不需要继续dfs直接跳出来得到答案，但是这个有一个bug的存在就是，你最短的路径并不等于n+m-1的时候，就必须找所有的可能依旧会超时，但是力扣数据有点。。就过了。剪枝+1。这个显然可过题但不是正解。

之后看了看正解：三维数组，第三个维度放的是清除了多少个障碍物。`d[x][y][z]`就表示走到x，y的时候清除了z个障碍物。最后只需要求得最多清除k个障碍走到n,m的最短路径就ok了。如果走到x，y永远清除的障碍物大于k。我们肯定是无法求得到达的最短路的。

剪枝法：

```
int vis[50][50];
    vector<vector<int>> tu;
    int m,n;
    int nxt[4][2]={0,1,1,0,0,-1,-1,0};
    int ans=0x3f3f3f3f;int flag=0;
    void dfs(int x,int y,int step,int use){
        if(use<0)return ;
        if(flag)return ;
        if(x==n-1&&y==m-1){
            ans=min(step,ans);
            if(ans==n+m-2)flag=1;return ;
        }if(tu[x][y])use--;
        for(int i=0;i<4;i++){
            int dx=x+nxt[i][0];int dy=y+nxt[i][1];
            
            if(dx<0||dy<0||dx>=n||dy>=m)continue;
            if(vis[dx][dy])continue;
            
            vis[dx][dy]=1;
            dfs(dx,dy,step+1,use);
            vis[dx][dy]=0;
        }
    }
    int shortestPath(vector<vector<int>>& grid, int k) {
        tu=grid;n=grid.size();m=grid[0].size();
        vis[0][0]=0;
        
        dfs(0,0,0,k);
        if(ans==0x3f3f3f3f)return -1;
        return ans;
    }
```

正解：复制的是这次周赛第一名的题解🤭

```
struct node{
        int x,y,k;
        node() {}
        node(int _x,int _y,int _k) { x=_x; y=_y; k=_k; }
    };
    int shortestPath(vector<vector<int>>& grid, int k) {
        queue<node> q;
        int n=grid.size(),m=grid[0].size();
        int d[n+10][m+10][k+10];
        memset(d, -1, sizeof(d));
        d[0][0][0] = 0; q.push(node(0,0,0));
        const int dx[4]={0,0,1,-1};
        const int dy[4]={1,-1,0,0};
        while (!q.empty()) {
            node u=q.front(); q.pop();
            for (int i=0;i!=4;++i) {
                int px=u.x+dx[i], py=u.y+dy[i];
                if (px>=0 && px<n && py>=0 && py<m && u.k+grid[px][py]<=k) {
                    if (d[px][py][u.k+grid[px][py]]==-1) {
                        d[px][py][u.k+grid[px][py]] = d[u.x][u.y][u.k] + 1;
                        q.push(node(px,py,u.k+grid[px][py]));
                    }
                }
            }
        }
        int ans=n*m+1;
        for (int i=0;i<=k;++i) if (d[n-1][m-1][i]!=-1)
            ans = min(ans, d[n-1][m-1][i]);
        if (ans==n*m+1) ans = -1;
        return ans;
    }
```

以上就是本次周赛的内容啦，如果觉得不错的话，点个在看和转发是对我最大的支持！！！

