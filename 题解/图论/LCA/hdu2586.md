//倍增法

```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn=40003;
int root[maxn][17];
int depth[maxn];
long long dis[maxn];
int head[maxn];
struct edge
{
	int v,u;
	int nxt;
	long long w;
}e[maxn<<1];
int cnt;
void add_edge(int u,int v,long long w)
{
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}

void dfs(int u,int pre,int deep)
{
	root[u][0]=pre;
	depth[u]=deep;
	
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		long long val=e[i].w;
		if(v==pre)continue;
		dis[v]=dis[u]+val;
		dfs(v,u,deep+1);
	}
}
int n;
void lca_init(int st)
{
	dfs(st,-1,0);
	
	for(int j=0;(1<<(j+1))<n;j++)
	{
		for(int i=1;i<=n;i++)
		{
			if(root[i][j]<0)root[i][j+1]=-1;
			else root[i][j+1]=root[root[i][j]][j];
		} 
	}
}

int LCA(int u,int v)
{
	if(depth[u]>depth[v])swap(u,v);
	
	int tmp=depth[v]-depth[u];
	for(int i=0;(1<<i)<=tmp;i++)
	{
		if((1<<i)&tmp)v=root[v][i];
	}
	if(v==u)return u;
	
	for(int i=log2(1.*n);i>=0;i--)
	{
		if(root[u][i]!=root[v][i])
		{
			v=root[v][i];
			u=root[u][i];
		}
	}
	return root[u][0];
}

int main()
{
	int t;cin>>t;
	
	while(t--)
	{
		int m;
		scanf("%d%d",&n,&m);
		cnt=0;
		
		memset(root,-1,sizeof root);
		memset(dis,0,sizeof dis);
		memset(head,-1,sizeof head);
		for(int i=1;i<=n-1;i++)
		{
			int u,v;long long w;
			scanf("%d%d%lld",&u,&v,&w);
			add_edge(u,v,w);
			add_edge(v,u,w);
		}
		lca_init(1);
		for(int i=0;i<m;i++)
		{
			int a,b;scanf("%d%d",&a,&b);
			long long ans=(dis[a]+dis[b]-2*dis[LCA(a,b)]);
			printf("%lld\n",ans);
		}
	}
} 
```

### TARJAN

```

#include<bits/stdc++.h>

using namespace std;
const int maxn=40004;

struct edge
{
	int v,nxt;
	long long w;
}e[maxn<<1];

int cnt;

int head[maxn];
int vis[maxn];
int fa[maxn];
long long  dis[maxn];
vector<int> other[maxn],id[maxn];
long long ans[maxn];
int get(int x){return x==fa[x]?fa[x]=x:get(fa[x]);}
void add_edge(int u,int v,long long w)
{
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}
void tar(int u)
{
	vis[u]=1;
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		if(vis[v]==0)
		{
			
			dis[v]=dis[u]+e[i].w;
			tar(v);
			fa[v]=u;//注意这里的要放tar后面
		}
	}
	
	for(int i=0;i<other[u].size();i++)
	{
		int v=other[u][i];
		int idx=id[u][i];
		
		if(vis[v]==2)
		{
			ans[idx]=dis[u]+dis[v]-2*dis[get(v)];
		}
	}
	vis[u]=2;
}
	

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,m;scanf("%d%d",&n,&m); 
		memset(vis,0,sizeof vis);
		memset(dis,0,sizeof dis);
		memset(head,-1,sizeof head);
		for(int i=0;i<=n;i++)fa[i]=i;
		for(int i=0;i<=n;i++)other[i].clear(),id[i].clear();
		for(int i=1;i<=n-1;i++)
		{
			int a,b;
			long long c;
			scanf("%d%d%lld",&a,&b,&c);
			add_edge(a,b,c);
			add_edge(b,a,c);
		} 
		
		for(int i=1;i<=m;i++)
		{
			int u,v;scanf("%d%d",&u,&v);
			if(u==v){
				ans[i]=0;continue;
			}
			other[u].push_back(v);id[u].push_back(i);
			other[v].push_back(u);id[v].push_back(i);
		}
		tar(1); 
		for(int i=1;i<=m;i++)
		{
			printf("%lld\n",ans[i]);
		}
	}
}
```



