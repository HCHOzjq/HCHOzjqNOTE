### 好题emm

次小生成树求法

对每条边进行枚举，再枚举与那条边同一个权值的边。如果存在那条边的两个点在同一个集合上的话。说明已经存在一条边将那两个点相连了。

```C++
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
const int maxn=100005;
int fa[maxn];
int get(int x){return x==fa[x]?x:fa[x]=get(fa[x]);}

struct edge
{
	int u,v,val;
	bool operator<(const edge&e)const{
	return val<e.val;}
}e[maxn];

int main()
{
	int t;
	scanf("%d",&t);
	
	while(t--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		
		for(int i=0;i<=n;i++){
			fa[i]=i;
		}
		for(int i=1;i<=m;i++){
			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].val);
		}
		sort(e+1,e+1+m);
		int last=0;
		int sum1,sum2;
		sum1=sum2=0;
		int num=0;
		int flag=1;
		int ans=0;
		for(int i=1;i<=m+1;i++)
		{
			if(last<i)
			{
				if(sum1!=sum2){
					flag=0;
					break;
				}
				sum1=0;
				for(int j=i;j<=m+1;j++)
				{
					if(e[i].val!=e[j].val){
						last=j-1;
						break;
					}
					if(get(e[j].u)!=get(e[j].v))sum1++;
				}
				sum2=0;
			}
				if(i>m)break;
				int x=get(e[i].u),y=get(e[i].v);
				if(x!=y&&num!=n-1){
					num++;
                    
					fa[x]=y;
					ans+=e[i].val;
					sum2++;
				} 
		}
		if(flag){
			cout<<ans<<endl;
		}else {
			cout<<"Not Unique!"<<endl;
		}
	}
}
```

