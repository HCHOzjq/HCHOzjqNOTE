```C++
#include<bits/stdc++.h>

using namespace std;

const int maxn=1004;
double e[maxn][maxn];
int used[maxn][maxn];
double maxcost[maxn][maxn];
double dis[maxn];
int pre[maxn];
double MST;
int vis[maxn];
struct no
{
	int x,y,p;
}city[maxn];

double dd(int a,int b)
{
	return sqrt((city[a].x-city[b].x)*(city[a].x-city[b].x)+(city[a].y-city[b].y)*(city[a].y-city[b].y));
}
int n;
void prim()
{
	memset(used,0,sizeof used);
	memset(maxcost,0,sizeof maxcost);
	for(int i=1;i<=n;i++){
		dis[i]=e[1][i];
		pre[i]=1;
		vis[i]=0;
	}
	for(int i=1;i<=n;i++){
		double maxv=1e9;
		int pos=-1;
		for(int j=1;j<=n;j++){
			if(vis[j]==0&&maxv>dis[j]){
				maxv=dis[j];
				pos=j;
			}
		}
		if(pos==-1)break;
		MST+=dis[pos];
		used[pre[pos]][pos]=used[pos][pre[pos]]=1;
		
		vis[pos]=1;
		for(int j=1;j<=n;j++){
			if(vis[j]&&j!=pos)maxcost[pos][j]=maxcost[j][pos]=max(maxcost[j][pre[pos]],dis[pos]);
			if(vis[j]==0&&dis[j]>e[pos][j]){
				dis[j]=e[pos][j];
				pre[j]=pos;
			}
		}
	}
}


int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d%d",&city[i].x,&city[i].y,&city[i].p);
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<i;j++){
				e[j][i]=e[i][j]=dd(i,j);
			}
			e[i][i]=0;
		}
		MST=0;prim();
		
		double ans=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<i;j++){
				if(used[i][j])ans=max(ans,(city[i].p+city[j].p)/(MST-e[i][j]));
				else ans=max(ans,(city[i].p+city[j].p)/(MST-maxcost[i][j]));
			}
		}
		printf("%.2lf\n",ans);
		
	}
}
```

求最小花费，每个城市有人口。有一个边可以免权值。但要让(两边人口)/(权值所有)最大化。



用prim容易写。要记住每个点的父节点，然后maxcost是记录经过这条边的最小生成树的边的最大值。具体看代码ORZ，感觉码力要好点才写得出来。。

maxcost的最大值可以是xy之间或者x的到x的父节点的maxcost，因为他包含在最小生成树里。