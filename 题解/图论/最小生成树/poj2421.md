

### poj 2421

最小生成树

注意的是，有一个是为0的。然后邻接矩阵要可以用`prim`算

放下prim的板子。

```C++
#include<iostream>
#include<cstring>
using namespace std;
int tu[104][104];
int dis[104];
int vis[105];
int main()
{
	int n;
	while(~scanf("%d",&n))
	{
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				scanf("%d",&tu[i][j]); 
			}
		}
		int m;scanf("%d",&m);
		for(int i=1;i<=m;i++){
			int a,b;
			scanf("%d%d",&a,&b);
			tu[a][b]=tu[b][a]=0;
		}
		int now=1;
		memset(dis,0x3f,sizeof dis);
		memset(vis,0,sizeof vis);
		dis[now]=0;
		int ans=0;
		while(true){
			int pos;
			int maxv=0x3f3f3f3f;
			for(int j=1;j<=n;j++){
				if(!vis[j]&&dis[j]<maxv){
					maxv=dis[j];
					pos=j;
				} 
			}
			
			if(maxv==0x3f3f3f3f)break;
			ans+=dis[pos];
			vis[pos]=1;
			for(int j=1;j<=n;j++){
				if(!vis[j]&&dis[j]>tu[pos][j]){//注意这里要更新的是那个点到其他点的距离
					dis[j]=tu[pos][j];			//而不是初始点到其他点的距离
				}
			}
		}
		cout<<ans<<endl;
		
	}
} 
```

