```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn=100005;

int cnt;
struct ee{
	int v,val;
};//vec存边 

struct edge//存边 
{
	int u,v,dis;
	bool operator<(const edge &n)const{
		return dis<n.dis;
	}
}e[maxn];

int vis[maxn];
vector<ee> g[maxn];
int fa[maxn];
int dep[maxn];

void add_edge(int u,int v,int dis)
{
	e[cnt].u=u,e[cnt].v=v;e[cnt++].dis=dis;
}
int get(int x){
	return fa[x]==x?fa[x]:fa[x]=get(fa[x]);
}
int anc[maxn][100];
int maxcost[maxn][100];
void dfs(int u,int fa)
{
	if(fa==-1)dep[u]=0;
	else dep[u]=dep[fa]+1;
	for(int i=1;(1<<i)<=dep[u];i++){
		if(anc[u][i-1]!=-1)
		{
			anc[u][i]=anc[anc[u][i-1]][i-1];
			maxcost[u][i]=max(maxcost[u][i-1],maxcost[anc[u][i-1]][i-1]);
		} 
		
	}

	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v;
		if(v!=fa)
		{
			anc[v][0]=u;
			maxcost[v][0]=g[u][i].val;
			dfs(v,u);
		}
	}
	return ;
}
int query(int a,int b)
{
	if(dep[a]<dep[b])swap(a,b);
	int log;
	for(log=1;(1<<log)<=dep[a];log++);log--;//求深度，迭代的次数 
	int ans=-1e9;
	for(int i=log;i>=0;i--){
		if((dep[a]-dep[b])>=(1<<i)){
			ans=max(maxcost[a][i],ans);a=anc[a][i];
		}	
	}
	if(a==b)return ans; 
	for(int i=log;i>=0;i--){
		if(anc[a][i]!=-1&&anc[a][i]!=anc[b][i]){
			ans=max(ans,maxcost[a][i]);a=anc[a][i]; 
			ans=max(ans,maxcost[b][i]);b=anc[b][i];
		}
	}
	ans=max(maxcost[a][0],ans);
	ans=max(maxcost[b][0],ans);
	return ans;
}


int main()
{
	//freopen("in.txt","r",stdin);
	int flag=0;
	
	int n,m;
	while(~scanf("%d%d",&n,&m)&&n&&m)
	{
		memset(maxcost,0,sizeof maxcost);
		memset(anc,-1,sizeof anc);
		cnt=0;	
		if(flag)cout<<endl;
		flag=1;
		for(int i=0;i<=n;i++)fa[i]=i,g[i].clear();
		for(int i=1;i<=m;i++){
			int a,b;int c;scanf("%d%d%d",&a,&b,&c);
			add_edge(a,b,c);	
		}
	
		int t;scanf("%d",&t);
		sort(e,e+cnt);
		int cc=0;
		for(int i=0;i<cnt;i++){
			int u=e[i].u,v=e[i].v;
			int x=get(u),y=get(v);
			if(x!=y)
			{
				cc++;
				fa[x]=y;
				g[u].push_back({v,e[i].dis});
				g[v].push_back({u,e[i].dis});
				if(cc==n-1)break;
			}
		}
		
		//上面没问题= =
		 
		dfs(1,-1);
		for(int i=0;i<t;i++){
			int a,b;
			scanf("%d%d",&a,&b);
			cout<<query(a,b)<<endl;
		}
	}
}
```

求最小生成树，之后，对树进行倍增操作，然后求得两条边之间的最大权值边。树上RMQ，LCA。