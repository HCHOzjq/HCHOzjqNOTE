

```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn=1000005;
int vis[maxn],dis[maxn];
struct edge
{
	int u,v,nxt;
	int val;
}e[maxn];
int cnt;
int dian[maxn];
int head[maxn];
int in[maxn];
int fa[maxn];
void add_edge(int u,int v,int val)
{
	e[cnt].v=v;
	e[cnt].val=val;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}
int n;
bool bf()
{
	queue<int> que;
	memset(vis,0,sizeof vis);
	memset(dis,0x3f,sizeof dis);
	memset(in,0,sizeof in);
	for(int i=1;i<=n;i++){
		que.push(i);vis[i]=1;
	}
	while(!que.empty())
	{
		int u=que.front();que.pop();
		vis[u]=0;
		for(int i=head[u];~i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].val){
				dis[v]=dis[u]+e[i].val;
			
				if(vis[v]==0)
				{
					vis[v]=1;
					que.push(v);	
					in[v]++;
					if(in[v]>n)return true;
				}
			} 
		}
	}
	return false;
}

bool check(int mid)
{
	for(int i=0;i<cnt;i++){
		e[i].val-=mid;
	}
	bool ok=bf();
	for(int i=0;i<cnt;i++){
		e[i].val+=mid;
	}
	return ok;
}

int main()
{
	int E;
	while(~scanf("%d%d",&n,&E))
	{
		cnt=0;memset(head,-1,sizeof head);
		int l=1,r=0;
		for(int i=0;i<E;i++)
		{
			int a,b,c;scanf("%d%d%d",&a,&b,&c);
			add_edge(a,b,c);
			r=max(c,r);
		}
		if(check(l)){
			cout<<"No Solution"<<endl;continue;
		}
		if(!check(r+1)){
			cout<<"Infinite"<<endl;continue;
		}
		int ans=0;
		while(l<r)
		{
			int mid=l+(r-l)/2;
			if(check(mid)){
				r=mid;
			}else {
				l=mid+1;
			}
		}
		cout<<l-1<<endl;
		
	}
```

主要是转换为差分约束的思想比较难想到，还有就bf的板子要这样子写。

题意是求最小值最大化。

求一个最小边权的最大值，对于一个点他的入边权值要-a，出边+a。然后二分出最小值的最大化。接下去bf判边。

`w(u,v)+sum(u)-sum(v)>=x`

`sum(v)-sum(u)<=w(u,v)-x`

x是枚举的值。要让负圈没出现的最大x值。