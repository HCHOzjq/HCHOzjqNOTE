# 计算几何

```
#include<cmath>
#include<queue>
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const double pi=acos(-1),eps=1e-10;
struct Point
{
    double x,y;
    Point(double x0=0,double y0=0) : x(x0) , y(y0) { }
    friend bool operator<(Point a,Point b)
    {
        return a.x!=b.x?a.x<b.x:a.y<b.y;
    }
    friend Point operator+(const Point &a,const Point &b)
    {
        return Point(a.x+b.x,a.y+b.y);
    }   
    friend Point operator-(const Point &a,const Point &b)
    {
        return Point(a.x-b.x,a.y-b.y);
    }
    friend Point operator*(const Point &a,double b)
    {
        return Point(a.x*b,a.y*b);
    }
    friend Point operator/(const Point &a,double b)
    {
        return Point(a.x/b,a.y/b);
    }
    friend bool operator==(const Point &a,const Point &b){
        return a.x==b.x&&a.y==b.y;
    }  
};
typedef Point Vector;
double dcmp(double x)//符号判断 
{
    if(fabs(x)<eps)return 0;
    else return x<0?-1:1;
}

double Dot(const Point &a,const Point &b)//点积 
{
    return a.x*b.x+a.y*b.y;
}
double Cross(const Point &a,const Point &b)//叉积 
{
    return a.x*b.y-a.y*b.x;
}
double Length(const Point &a)//求向量的长度 
{
    return sqrt(Dot(a,a));
}
double Angle(const Point &a,const Point &b)//求两个向量的夹角（余弦定理） 
{
    return acos(Dot(a,b)/Length(a)/Length(b));//A^B=|A|*|B|*cosC
}
Point Rotate(const Point &a,double rad)//逆时针旋转rad，r一个圆的rad为2pi
{
    return Point(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
}
Point Normal(Point &v)//求单位长度的法向量 
{
    double L=Length(v);
    return Point(-v.y/L,v.x/L);
}
Point getLineIntersection(const Point &P,const Point &v,const Point &Q,const Point &w)//求两个线段交点//Pv和Qw
{
    Vector u=P-Q;
    double t=Cross(w,u)/Cross(v,w);
    return P+v*t;
}
bool SegmentProperIntersection(const Point &a1,const Point &b1,const Point &a2,const Point &b2)//两线段规范相交、即每条线段的端点分别在另一条一段的两侧 
{
    double c1=Cross(b1-a1,a2-a1),c2=Cross(b1-a1,b2-a1);
    double c3=Cross(b2-a2,a1-a2),c4=Cross(b2-a2,b1-a2);
    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;
}
bool unnorm_Inter(const Point &a1,const Point &b1,const Point &a2,const Point &b2)//不规范相交
{
    return
    max( a1.x , b1.x )>=min( a2.x , b2.x )&&
    max( a2.x , b2.x )>=min( a1.x , b1.x )&&
    max( a1.y , b1.y )>=min( a2.y , b2.y )&&
    max( a2.y , b2.y )>=min( a1.y , b1.y )&&
    dcmp(Cross((a2-b1),(a1-b1)))*dcmp(Cross((b2-b1),(b1-b1)))<=0&&
    dcmp(Cross((a1-b2),(a2-b2)))*dcmp(Cross((b1-b2),(a2-b2)))<=0;
}

bool IsPointOnSegment(Point p,Point a1,Point a2)//点在线段上/直线
{
    return dcmp(Cross(p-a1,p-a2))==0 && dcmp(Dot(p-a1,p-a2))<0;
    //线上两点与待定点的差积为0，且点积小于0，两线段表示反方向，去掉第二个判断条件就是在直线上
}
double getDistToLine(const Point &P, const Point &A, const Point &B)//点到直线的有向距离（距离加绝对值） 
{
    Vector AB = B-A, AP = P-A;
    return Cross(AB, AP) / Length(AB);
}
double Area2(Point A, Point B, Point C){//计算BA,CA所构成的平行四边形的有向面积
    return Cross(B-A, C-A);
}
bool ToLeftTest(Point a, Point b, Point c){//判断ab在bc的顺时针方向
    return Cross(b - a, c - b) > 0;
}
Point GetLineProjection(Point P, Point A, Point B){//点P在直线AB上的投影点
    Vector v = B-A;
    return A+v*(Dot(v, P-A)/Dot(v, v));
}
//========================//
int ConvexHull(Point *p,int n,Point *ch)//构造逆时针凸包 //Andrew法，先求上凸包，再求下凸包
{
    sort(p+1,p+n+1);//先按照横坐标再按照纵坐标排序 
    int m=0;
    for(int i=1;i<=n;i++)
    {
        while(m>1 && Cross(ch[m]-ch[m-1],p[i]-ch[m-1])<=0)m--;
        ch[++m]=p[i];
    }
    int k=m;
    for(int i=n-1;i;i--)
    {
        while(m>k && Cross(ch[m]-ch[m-1],p[i]-ch[m-1])<=0)m--;
        ch[++m]=p[i];
    }
    if(n>1)m--;
    return m;
}
double PolygonArea(Point *p,int n)//求逆时针构成的多边形（可不凸）面积 
{
    double ret=0;
    for(int i=2;i<n;i++)//第一个点是p[1],所以这样循环 
        ret+=Cross(p[i]-p[1],p[i+1]-p[1]);
    return ret/2;
}

bool isPointInPolygon(Point p,Point *poly,int n)//点在凸多边形内的判定 
{
    int wn=0;
    poly[n+1]=poly[1];
    for(int i=1;i<=n;i++)
    {
        if(IsPointOnSegment(p,poly[i],poly[i+1]))return -1;
        int k=dcmp(Cross(poly[i+1]-poly[i],p-poly[i]));
        int d1=dcmp(poly[i].y-p.y);
        int d2=dcmp(poly[i+1].y-p.y);
        if(k>0 && d1<=0 && d2>0)wn++;
        if(k<0 && d2<=0 && d1>0)wn--;
    }
    if(wn!=0)return 1;
    return 0;
}
void update(int a,int b){}
int findDiameter(Point *p,int n)//旋转卡壳求直径（Diatmeter：直径）
{
    int mx=0,j=2;
    p[n+1]=p[1];
    for(int i=1;i<=n;i++)
    {
        while(dcmp(Cross(p[i+1]-p[i],p[j+1]-p[j]))>0)
        {
            j++;
            j=(j-1)%n+1;
        }
        update(i,j);
        update(i+1,j);
        update(i,j+1);
        update(i+1,j+1);
    }
    return mx;
}
struct Line
{
    Point P;Vector v;
    double ang;
    Line() {}
    Line(Point P,Vector v):P(P),v(v){ang=atan2(v.y,v.x);}
    Point point(double t){
        return v+(P-v)*t;
    }
    friend bool operator<(Line a,Line b)
    {
        return  a.ang<b.ang;
    }
};
Point GetIntersection(Line a,Line b)//交点，要保证两直线相交，不然出现除数为0的情况
{
    Vector u=a.P-b.P;
    double t=Cross(b.v,u)/Cross(a.v,b.v);
    return a.P+a.v*t;
}
double DistanceToSegment(Point P, Point A, Point B){//点到线段的距离
    if(A == B)
        return Length(P-A);
    Vector v1 = B-A, v2 = P-A, v3 = P-B;
    if(dcmp(Dot(v1, v2)) < 0)
        return Length(v2);
    if(dcmp(Dot(v1, v3)) > 0)
        return Length(v3);
    return getDistToLine(P, A, B);
}
bool OnLeft(Line L,Point p)//暂时不懂什么意思，要推一下
{
    return Cross(L.v,p-L.P)>=0;
}
int HalfplaneIntersection(Line *L,int n,Point *poly)//半平面交 ，输入向量要逆时针输入，要是wa了可以把向量方向反下
{
    sort(L+1,L+n+1);//极角排序
    int first,last;
    Point *p=new Point[n+10];
    Line *q=new Line[n+10];
    q[first=last=0]=L[1];
    for(int i=2;i<=n;i++)
    {
        while(first<last && !OnLeft(L[i],p[last-1]))last--;
        while(first<last && !OnLeft(L[i],p[first]))first++;
        q[++last]=L[i];
        if(fabs(Cross(q[last].v,q[last-1].v))<eps)
        {
            last--;
            if(OnLeft(q[last],L[i].P))q[last]=L[i];
        }
        if(first<last)p[last-1]=GetIntersection(q[last-1],q[last]);
    }
    while(first<last && !OnLeft(q[first],p[last-1]))last--;
    if(last-first<=1)return 0;
    p[last]=GetIntersection(q[last],q[first]);
    int m=0;
    for(int i=first;i<=last;i++)poly[++m]=p[i];
    return m;
}
bool OK(Point A,Point B,Point C,Point D)
{
    int a=Cross(A-C,D-C)>0;
    int b=Cross(B-C,D-C)>0;
    if(a!=b)return true;
    else return false;
}
struct Circle{
    Point c;
    double r;
    Circle(Point c, double r):c(c), r(r) {}
    Point point(double a){//通过圆心角求坐标
        return Point(c.x + cos(a)*r, c.y + sin(a)*r);
    }
};
int getLineCircleIntersection(Point A,Point B, Circle C, double& t1, double& t2, vector<Point>& sol){//求圆与直线交点
    double a = A.x, b = B.x - C.c.x, c = A.y, d = B.y - C.c.y;
    double e = a*a + c*c, f = 2*(a*b + c*d), g = b*b + d*d - C.r*C.r;
    double delta = f*f - 4*e*g;//判别式
    if(dcmp(delta) < 0)//相离
        return 0;
    if(dcmp(delta) == 0){//相切
        t1 = -f /(2*e);
        t2 = -f /(2*e);
        sol.push_back(Point(A.x+(B.x-A.x)*t1,A.y+(B.y-A.y)*t1));//sol存放交点本身
        return 1;
    }
    //相交
    t1 = (-f - sqrt(delta))/(2*e);
    sol.push_back(Point(A.x+(B.x-A.x)*t1,A.y+(B.y-A.y)*t1));
    t2 = (-f + sqrt(delta))/(2*e);
    sol.push_back(Point(A.x+(B.x-A.x)*t2,A.y+(B.y-A.y)*t2));
    return 2;
}
double AreaOfOverlap(Point c1, double r1, Point c2, double r2){//两个圆相交所构成的两个扇形面积和减去其构成的筝形的面积
    double d = Length(c1 - c2);
    if(r1 + r2 < d + eps)
        return 0.0;
    if(d < fabs(r1 - r2) + eps){
        double r = min(r1, r2);
        return pi*r*r;
    }
    double x = (d*d + r1*r1 - r2*r2)/(2.0*d);
    double p = (r1 + r2 + d)/2.0;
    double t1 = acos(x/r1);
    double t2 = acos((d - x)/r2);
    double s1 = r1*r1*t1;
    double s2 = r2*r2*t2;
    double s3 = 2*sqrt(p*(p - r1)*(p - r2)*(p - d));
    return s1 + s2 - s3;
}

Point getcircle(Point p1,Point p2)//求以p1,p2为弦的圆心
{
    Point mid = Point((p1.x+p2.x)/2,(p2.y+p1.y)/2);
    double angle = atan2(p2.y-p1.y,p2.x-p1.x);
    double d = sqrt(1.0-Length(p1-mid)*Length(p1-mid));
    return Point(mid.x+d*sin(angle),mid.y-d*cos(angle));
}

//过三点求圆心坐标
//3种做法
//====================//
Point waixin(Point a,Point b,Point c)//这个需要先判断是不是在同一条线上，必要的时候可以把除法去掉，如下面另外一个板子的做法
{
  double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1*a1 + b1*b1)/2;
  double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2*a2 + b2*b2)/2;
  double d = a1*b2 - a2*b1;//为0的话，三点共线特判一下
  
  return Point(a.x + (c1*b2 - c2*b1)/d, a.y + (a1*c2 -a2*c1)/d);
}

typedef long long ll;
struct node
{
    ll x,y,d;
};
node circle_center(const Point a,const Point b,const Point c)
{
    node center;
    ll a1 = b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1);
    ll a2 = c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2);
    center.d=a1*b2-a2*b1;
    if(center.d==0){//判断3点共线
        center.x=1e18;
        return center;
    }
    center.x=c1*b2-c2*b1;
    center.y=a1*c2-a2*c1;

    return center;
}//求圆心
void Cir(double ax,double ay,double bx,double by,double cx,double cy,double &x,double &y)
{
     double a1=atan2(by-ay,bx-ax)+acos(-1.)/2;
     double a2=atan2(cy-by,cx-bx)+acos(-1.)/2;
     ax=(ax+bx)/2,ay=(ay+by)/2;
     bx=(cx+bx)/2,by=(cy+by)/2;
     double r=(sin(a2)*(ax-bx)+cos(a2)*(by-ay))/(sin(a1)*cos(a2)-sin(a2)*cos(a1));
     x=ax+r*cos(a1),y=ay+r*sin(a1);
}

//三角形面积，海伦公式：sqrt(p*(p-a)*(p-b)*(p-c)),p=(a+b+c)/2
//a*b*sinC/2
//外心（板子有了）三边中垂线交点，到三角形三个顶点距离相同
//内心：角平分线的交点，到三角形三边的距离相同，先求向量的角度，然后用rotate求两个线段，再求交点
//垂心：三条高线的交点，对两条边旋转90°，之后求交点
//重心：三条中线的交点，到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点
//任意凸多边形外角和均为360°、
// 任意凸多边形内角和为(n−2)180°
//pick定理：2*S=2*a+b-2,S表示多边形面积，a表示多边形内部点数，b表示多边形边界上的点数
//
/*tan和atan接受的输出都是弧度需要转换
前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个
因为atan的值域是从-90~90也就是它只处理一四象限，所以一般不用它。第二个atan2(double y,double x) 其中y代表已知点的Y坐标 
同理x 返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了。
*/
//================================//

int main()
{
    int n;
    while(~scanf("%d",&n)){

    }
    return 0;
}


```

# 笛卡尔树

```
#include<bits/stdc++.h>
//必要时可以+fa[maxn];
using namespace std;
const int maxn=2e6+10;
long long p[maxn];
long long d[maxn];
long long s[maxn];
long long ls[maxn],rs[maxn];
long long dfn[maxn];
int tot;
const long long mod=1e9+7;
long long inf=1e18;
void dfs(int l,int r,int rt)
{
	if(l>r)return ;
	if(l==r){
		dfn[l]=tot++;return ;
	}
	if(p[rt]==inf){
		for(int i=l;i<=r;i++){
			dfn[i]=tot++;
		}
		return ;
	}else if(p[rt]%10<d[rt]){dfs(l,rt,ls[rt]);dfs(rt+1,r,rs[rt]);}
	else {dfs(rt+1,r,rs[rt]);dfs(l,rt,ls[rt]);}
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		tot=0;
		long long seed,pa,pb,pm;
		long long seedb,pab,pbb,pmb;
		scanf("%lld%lld%lld%lld",&seed,&pa,&pb,&pm);
		scanf("%lld%lld%lld%lld",&seedb,&pab,&pbb,&pmb);
		long long has=1;
		for(int i=0;i<n;i++){
			p[i]=i;
			ls[i]=rs[i]=0;
			d[i]=seedb%10;
			seedb=(seedb*pab+pbb)%pmb;
		}
		ls[n]=rs[n]=0;
		for(int i=1;i<n;i++){
			swap(p[seed%(i+1)],p[i]);
			seed=(seed*pa+pb)%pm;
		}
		for(int i=0;i<n;i++){
			if(p[i]%10==d[i])p[i]=inf;
		}
		int top;
		top=0;
		for(int i=0;i<n;i++){
			while(top&&p[s[top]]>p[i]){
				ls[i]=s[top];top--;
			}
			if(top)rs[s[top]]=i;
			s[++top]=i;
		}
		dfs(0,n,s[1]);
		long long ans=0;
		for(int i=0;i<=n;i++){
			ans+=(dfn[i]*has)%mod;
			ans%=mod;
			has=has*10000019;
			has%=mod;
		}
		printf("%lld\n",ans);
	}
}
```

# 虚树

```
#include<bits/stdc++.h>

const long long maxn=250010*2;
using namespace std;
struct edge
{
    long long v,nxt,w;
}e[maxn];
long long cnt;
long long head[maxn];
long long rnk[maxn],dfn[maxn],top[maxn],sz[maxn],fa[maxn];
long long son[maxn];
long long d[maxn];
long long tim;
long long mn[maxn];
vector<long long> g[maxn];
long long s[maxn];
void add(long long u,long long v,long long w)
{
    e[cnt].w=w;e[cnt].v=v;e[cnt].nxt=head[u];head[u]=cnt++;
}
void dfs1(long long u,long long f)
{
    sz[u]=1;fa[u]=f;
    d[u]=d[f]+1;
    for(long long i=head[u];~i;i=e[i].nxt){
        long long v=e[i].v;if(v==f)continue;
        mn[v]=min(mn[u],e[i].w);
        dfs1(v,u);
        sz[u]+=sz[v];

        if(sz[son[u]]<sz[v]){
            son[u]=v;
        }
    }
}
void dfs2(long long u,long long f)
{
    if(son[u]){
        dfn[son[u]]=++tim;
        rnk[tim]=son[u];
        top[son[u]]=top[u];
        dfs2(son[u],u);
    }
    for(long long i=head[u];~i;i=e[i].nxt){
        long long v=e[i].v;if(v==f||v==son[u])continue;
        dfn[v]=++tim;
        rnk[tim]=v;
        top[v]=v;
        dfs2(v,u);
    }
}
long long LCA(long long a,long long b)
{
    long long ta=top[a],tb=top[b];
    while(ta!=tb){
        if(d[ta]<d[tb])swap(ta,tb),swap(a,b);
        a=fa[ta],ta=top[a];
    }
    if(d[a]<d[b])return a;
    else return b;
}

void add2(long long u,long long v)
{
    g[u].push_back(v);
}
long long TOP;
void ins(long long now)
{
    if(TOP==1){
        s[++TOP]=now;return ;
    }
    long long lca=LCA(s[TOP],now);
    // cout<<s[TOP]<<" "<<now<<" "<<lca<<"LCA"<<endl;
    if(lca==s[TOP]){
        return;
    }
    while(TOP>=2&&dfn[s[TOP-1]]>=dfn[lca]){
        add2(s[TOP-1],s[TOP]);//y->x
        TOP--;
    }
    if(s[TOP]!=lca)
    {
        add2(lca,s[TOP]);
        s[TOP]=lca;
    }
    s[++TOP]=now;
}

long long K[maxn];
bool cmp(const long long &a,const long long &b){
    return dfn[a]<dfn[b];
}

long long DP(long long u)
{
    if(g[u].size()==0)return mn[u];
    long long sum=0;
    for(long long i=0;i<g[u].size();i++){
        long long v=g[u][i];
        sum+=DP(v);
    }
    g[u].clear();
    return min(sum,(long long)mn[u]);
}

void getAns(long long n)
{
    TOP=1;
    s[TOP]=1;
    sort(K+1,K+1+n,cmp);
    for(long long i=1;i<=n;i++){
         ins(K[i]);
    }
    while(TOP>=1){
        add2(s[TOP-1],s[TOP]);
        TOP--;
    }
    cout<<DP(1)<<endl;
}

int main()
{
    long long n;
    scanf("%lld",&n);
    memset(head,-1,sizeof head);
    for(long long i=1;i<=n-1;i++){
        long long a,b,c;
        scanf("%lld%lld%lld",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    mn[1]=1e18;
    dfs1(1,0);
    rnk[1]=top[1]=dfn[1]=1;tim=1;
    dfs2(1,0);
    long long m;
    scanf("%lld",&m);
    for(long long i=1;i<=m;i++){
        long long x;
        scanf("%lld",&x);
        for(long long j=1;j<=x;j++){
            scanf("%lld",&K[j]);
        }
        getAns(x);
    }
}
```

# splay树

```
#include<bits/stdc++.h>

using namespace std;
const int maxn=1e5+10;
int son[maxn][2],sz[maxn],num[maxn];
int fa[maxn],val[maxn];

bool get(int x){return x==son[fa[x]][1];}
void maintain(int x){sz[x]=sz[son[x][0]]+sz[son[x][1]]+num[x];}
void clear(int x){son[x][0]=son[x][1]=fa[x]=sz[x]=num[x]=val[x]=0;}

void rotate(int x)
{
    int y=fa[x];
    int z=fa[y];
    int d=get(x);
    son[y][d]=son[x][d^1],fa[son[x][d^1]]=y;
    son[x][d^1]=y,fa[y]=x;
    fa[x]=z;
    if(z)son[z][son[z][1]==y]=x;
    maintain(x);
    maintain(y);
    return ;
}
int rt;
void splay(int cur)
{
    for(int f=fa[cur];f=fa[cur],f;rotate(cur)){
        if(fa[f]){rotate(get(cur)==get(f)?f:cur);}
    }
    rt=cur;
}
int tot;
void ins(int x)
{
    if(!rt){
        rt=++tot;
        sz[tot]=1;
        num[tot]=1;
        val[tot]=x;
        maintain(tot);
        return ;
    }
    int cur=rt;
    int f=0;
    while(1){
        if(val[cur]==x){
            num[cur]++;
            maintain(cur);
            maintain(f);
            splay(cur);
            break;
        }
        f=cur;
        cur=son[cur][val[cur]<x];
        if(!cur)
        {
            cur=++tot;
            val[tot]=x;
            fa[tot]=f;
            num[tot]=1;
            son[f][val[f]<x]=tot;
            maintain(tot);
            maintain(f);
            splay(tot);
            break;
        }

    }
}
int pre()
{
    int cnr=son[rt][0];
    while(son[cnr][1])cnr=son[cnr][1];
    splay(cnr);
    return cnr;
}
int suf()
{
    int cnr=son[rt][1];
    while(son[cnr][0])cnr=son[cnr][0];
    splay(cnr);
    return cnr;
}

int Rank(int x)//查找他的排名
{
    int cur=rt;
    int res=0;
    while(1){
        if(x<val[cur]){
            cur=son[cur][0];
        }else {
            res+=sz[son[cur][0]];
            if(x==val[cur]){
                splay(cur);
                return res+1;
            }
            res+=num[cur];
            cur=son[cur][1];
        }
    }

}

int find(int x)//查找排名为x的数字
{
    int cur=rt;
    while(1){
        if(son[cur][0]&&x<=sz[son[cur][0]]){
            cur=son[cur][0];
        }else {
            x-=sz[son[cur][0]]+num[cur];
            if(x<=0){
                splay(cur);
                return val[cur];
            }
            cur=son[cur][1];
        }
    }
}


void del(int x)
{
    Rank(x);
    if(num[rt]>1){
        num[rt]--;
        maintain(rt);
        return ;
    }
    if(!son[rt][0]&&!son[rt][1]){
        clear(rt);
        rt=0;
        return ;
    }
    if(!son[rt][0]){
        int cnr=rt;
        rt=son[rt][1];
        fa[rt]=0;
        clear(cnr);
        return ;
    }
    if(!son[rt][1]){
        int cnr=rt;
        rt=son[rt][0];
        fa[rt]=0;
        clear(cnr);
        return ;
    }
    int cnr=rt,now=pre();
    splay(now);
    fa[son[cnr][1]]=now;
    son[now][1]=son[cnr][1];
    clear(cnr);
    maintain(rt);
}

int main()
{
    int n;
    cin>>n;
    
    for(int i=1;i<=n;i++){
        int a,b;
        cin>>a>>b;
        if(a==1){
            ins(b);
        }else if(a==2){
            del(b);
        }else if(a==3){
            cout<<Rank(b)<<endl;
        }else if(a==4){
            cout<<find(b)<<endl;
        }else if(a==5){
            ins(b);cout<<val[pre()]<<endl;
            del(b);
        }else if(a==6){
            ins(b);cout<<val[suf()]<<endl;
            del(b);
        }
    }
}
```

# treap树

```
#include<bits/stdc++.h>

using namespace std;
const int maxn=2e5+10;
int son[maxn][2];
int sz[maxn];
int d[maxn];
int val[maxn];
int tot;
int num[maxn];

void pushup(int p)
{
    sz[p]=sz[son[p][0]]+sz[son[p][1]]+num[p];
}
int rd[maxn];
void rotate(int &p,int d)
{
    int k=son[p][d^1];
    son[p][d^1]=son[k][d];
    son[k][d]=p;
    pushup(p);
    pushup(k);
    p=k;
}
void ins(int &p,int x)
{
    if(!p){
        p=++tot;
        val[p]=x;
        sz[p]=1;
        num[p]=1;
        rd[p]=rand();
        return ;
    }
    if(val[p]==x){
        sz[p]++;
        num[p]++;
        return ;
    }
    int d=(x>val[p]);
    ins(son[p][d],x);
    if(rd[p]<rd[son[p][d]])
        rotate(p,d^1);
    pushup(p);
}


void del(int &p,int x)
{
    if(!p)return ;
    if(val[p]<x){
        del(son[p][1],x);
    }else if(val[p]>x){
        del(son[p][0],x);
    }else {
        if(!son[p][0]&&!son[p][1]){
            sz[p]--;
            num[p]--;
            if(num[p]==0)p=0;
        }else if(!son[p][0]&&son[p][1]){
            rotate(p,0);
            del(son[p][0],x);
        }else if(!son[p][1]&&son[p][0]){
            rotate(p,1);
            del(son[p][1],x);
        }else {
            int d=(rd[son[p][1]]<rd[son[p][0]]);
            rotate(p,d);
            del(son[p][d],x);
        }
    }
    pushup(p);
}
int Rank(int p,int x)
{
    if(!p)return 0;
    if(val[p]==x)return sz[son[p][0]]+1;
    else if(val[p]>x){
        return Rank(son[p][0],x);
    }else if(val[p]<x){
        return Rank(son[p][1],x)+sz[son[p][0]]+num[p];
    }
}
int find(int p,int x)
{
    if(!p)return 0;
    if(sz[son[p][0]]>=x)return find(son[p][0],x);
    if(sz[son[p][0]]+num[p]<x)return find(son[p][1],x-sz[son[p][0]]-num[p]);
    return val[p];
}
const int inf=1e9;

int pre(int p,int x)//找小于他的最大值
{
    if(!p)return -inf;
    if(x<=val[p])return pre(son[p][0],x);
    return max(val[p],pre(son[p][1],x));
}

int suf(int p,int x)//找大于他的最小值
{
    if(!p)return inf;
    if(x>=val[p])return suf(son[p][1],x);
    return min(val[p],suf(son[p][0],x));
}

int main()
{
    int t;
    cin>>t;
    int rt=0;
    srand(unsigned(time(0)));
    tot=0;
    while(t--){
        int a,b;
        cin>>a>>b;
        if(a==1){
            ins(rt,b);
        }else if(a==2){
            del(rt,b);
        }else if(a==3){
            cout<<Rank(rt,b)<<endl;
        }else if(a==4){
            cout<<find(rt,b)<<endl;
        }else if(a==5){
            cout<<pre(rt,b)<<endl;
        }else {
            cout<<suf(rt,b)<<endl;
        }
    }
}
```

# exgcd

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
long long a[100005];
int vis[100005];

void exgcd(long long a,long long b,long long &x,long long &y,long long &c){//其中a%b的逆元为x,c为gcd
    if(!b){y=0;x=1;c=a;return ;}
    else {
        exgcd(b,a%b,y,x,c);y-=(a/b)*x;
    }
}//推理一下
long long b[100005];
int main()
{
    long long n,k;
    scanf("%lld%lld",&n,&k);
    for(long long i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    vector<long long> v;
    for(long long i=1;i<=n;i++){
        if(vis[i]==0){
            vis[i]=1;
            long long cnt=1;
            long long tmp=a[i];
            v.clear();
            v.push_back(i);
            while(tmp!=i){
                vis[tmp]=1;
                v.push_back(tmp);
                cnt++;
                tmp=a[tmp];
            }
            if(cnt==1){
                b[i]=i;
                continue;
            }
            long long inv,y,c;
            exgcd(k%cnt,cnt,inv,y,c);
            if(inv<0)inv+=cnt;
            for(int j=0;j<v.size();j++){
                b[v[j]]=v[(j+inv)%v.size()];
            }
        }
    }
    for(int i=1;i<=n;i++){
        printf("%lld ",b[i]);
    }
    
    
}
```

# 广义后缀自动机

```
#include<bits/stdc++.h>

using namespace std;
const int maxn=6e5+10;
struct node
{
    int fa,ch[26],len;
}no[maxn];
int tot;
int add_no(int u,int last)
{
    if(no[last].ch[u]&&no[no[last].ch[u]].len==no[last].len+1)
        return no[last].ch[u];

    int p=last,np=++tot;
    int now;
    no[np].len=no[last].len+1;
    for(;p&&!no[p].ch[u];p=no[p].fa)no[p].ch[u]=np;
    int flag=0;
    if(!p)no[np].fa=1;
    else {
        int q=no[p].ch[u];
        if(no[q].len==no[p].len+1)no[np].fa=q;
        else {
            if(no[np].len==no[p].len+1)flag=1;//什么时候放后面的呢？
            now=++tot;memcpy(no[now].ch,no[q].ch,sizeof(no[now].ch));

            no[now].fa=no[q].fa;
            no[now].len=no[p].len+1;
            no[np].fa=no[q].fa=now;
            for(;p&&no[p].ch[u]==q;p=no[p].fa)no[p].ch[u]=now;
        }
    }
    return flag?now:np;
}

char str[maxn];
int b[maxn];
int id[maxn];
int rt[maxn];
int fa[maxn];
int cnt[maxn];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    scanf("%s",str);
    tot=1;
    rt[1]=add_no(str[0]-'A',1);
    for(int i=2;i<=n;i++){
        int x;
        scanf("%d",&x);
        fa[i]=x;
        rt[i]=add_no(str[i-1]-'A',rt[fa[i]]);
    }
    // cout<<endl;
    for(int i=1;i<=n;i++)cnt[rt[i]]++;
    for(int i=0;i<=tot;i++)b[i]=0;
    for(int i=1;i<=tot;i++)b[no[i].len]++;
    for(int i=1;i<=tot;i++)b[i]+=b[i-1];
    for(int i=1;i<=tot;i++)id[b[no[i].len]--]=i;
    for(int i=tot;i>=1;i--){
        int u=id[i];
        cnt[no[u].fa]+=cnt[u];
        // cout<<cnt[u]<<endl;
    }
    while(m--){
        int a,b;
        scanf("%d%d",&a,&b);
        int p=rt[a];
        while(no[no[p].fa].len>=b){
            p=no[p].fa;
        }
        printf("%d\n",cnt[p]);
    }

}
```

# 后缀数组

```
#include <bits/stdc++.h>

using namespace std;
const int maxn=2e6+10;

int hgt[maxn];
int a[maxn],sa[maxn],Rank[maxn],tax[maxn],tp[maxn];
int n,m;
void Rsort()
{
    for(int i=0;i<=m;i++)tax[i]=0;
    for(int i=1;i<=n;i++)tax[Rank[tp[i]]]++;
    for(int i=1;i<=m;i++)tax[i]+=tax[i-1];
    for(int i=n;i>=1;i--)sa[tax[Rank[tp[i]]]--]=tp[i];
}

bool cmp(int *f,int x,int y,int w)
{
    return f[x]==f[y]&&f[x+w]==f[y+w];
}

void Sa()
{
    for(int i=1;i<=n;i++)Rank[i]=a[i],tp[i]=i;
    m=256;Rsort();
    for(int p=1,w=1;p<n;m=p,w+=w)
    {
        int i;
        for(p=0,i=n-w+1;i<=n;i++)tp[++p]=i;
        for(i=1;i<=n;i++)if(sa[i]>w)tp[++p]=sa[i]-w;
        Rsort();swap(tp,Rank);Rank[sa[1]]=p=1;
        for(int i=2;i<=n;i++)Rank[sa[i]]=cmp(tp,sa[i],sa[i-1],w)?p:++p;
    }
    int i,j;
    int k=0;
    for(i=1;i<=n;hgt[Rank[i++]]=k){
        for(k=k?k-1:k,j=sa[Rank[i]-1];a[i+k]==a[j+k];k++);
    }
}
int dp[2000006][25];
void RMQinit()
{
    for(int i=2;i<=n;i++)dp[i][0]=hgt[i];
    //for(int i=1;i<=n;i++)cout<<" "<<dp[i][0];cout<<endl;
    for(int j=1;(1<<j)<=n;j++){
        for(int i=2;i+(1<<j)-1<=n;i++){
            dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
        }
    }
}
int RMQ(int l,int r)
{
    int k=0;while(r-l+1>=(1<<(k+1)))k++;
    return min(dp[l][k],dp[r-(1<<k)+1][k]);
}

int LCP(int a,int b)//排名多少
{
    if(a>b)swap(a,b);
    return RMQ(a+1,b);
}
char s[maxn];


int pre[maxn],last[maxn];
int main()
{
    int t;
    cin>>t;int kk=1;
    while(t--){
        scanf("%s",s+1);
        n=strlen(s+1);
        memset(a,0,sizeof a);
        for(int i=1;i<=n;i++)a[i]=s[i];
        Sa();
        for(int i=1;i<=n;i++){
            if(hgt[i]==0)pre[i]=i;
            else pre[i]=pre[i-1];
        }//
        for(int i=n;i>=1;i--){
            if(hgt[i+1]==0||i==n)last[i]=i;
            else last[i]=last[i+1];
        }
        printf("Case #%d:\n",kk++);
        int i=1;
        
        while(i<=n)
        {
            int k,t;
            k=0,t=i;
            int now=Rank[i];
            int len=hgt[now];
            for(int j=now-1;j>=pre[now];j--){
                len=min(len,hgt[j+1]);//
                if(len<k)break;
                if(sa[j]<i&&(len>k||len==k&&sa[j]<t)){
                    k=len;t=sa[j];
                }
            }
            if(now+1<=last[now])len=hgt[now+1];
            for(int j=now+1;j<=last[now];j++){
                len=min(len,hgt[j]);
                if(len<k)break;
                if(sa[j]<i&&(len>k||len==k&&sa[j]<t)){
                    k=len;t=sa[j];
                }
            } 
            if(k==0)printf("-1 %d\n",s[i]);
            else printf("%d %d\n",k,t-1);
            if(k==0)i++;
            else i+=k;
        }
    }

}
```

# 后缀数组（更快的版，复制版本，还没怎么改）

```
#include <bits/stdc++.h>
using namespace std;
struct _IO{_IO(){ios::sync_with_stdio(0);cin.tie(0);}}_io;
typedef long long ll; typedef long double db;
const int N = 2e6 + 5, M = 1e9 + 7;
  
int sa[N], rk[N], oldrk[N << 1], id[N], px[N], cnt[N];
// px[i] = rk[id[i]]（用于排序的数组所以叫 px）
  
bool cmp(int x, int y, int w) {
  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
}
  
void da(int *s, int n, int m) {
    int i,p,w;
    for(int i=0;i<=n;i++)cnt[i]=0;
 for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
  for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
  for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
  
  for (w = 1; w < n; w <<= 1, m = p) {  // m=p 就是优化计数排序值域
    for (p = 0, i = n; i > n - w; --i) id[++p] = i;
    for (i = 1; i <= n; ++i)
      if (sa[i] > w) id[++p] = sa[i] - w;
    //memset(cnt, 0, sizeof(cnt));
    for(int i=0;i<=n;i++)cnt[i]=0;
    for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
    for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
    for(int i=0;i<=n;i++)oldrk[i]=rk[i];
    //memcpy(oldrk, rk, sizeof(rk));
    for (p = 0, i = 1; i <= n; ++i)
      rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
  }
  
}
struct node
{
    int a,b,idx;
    bool operator<(const node&n)const{
        if(n.a==a)return b<n.b;
        else return a<n.a;
    }
}no[N];
char str[N];
int a[N];
int MP[3]={0};
int main()
{
    int n;
    while(~scanf("%d",&n)){
        scanf("%s",str);
        MP[0]=MP[1]=-1;
        for(int i=0;i<n;i++){
            if(str[i]=='a'&&MP[0]!=-1){
                a[i+1]=i+1-MP[0];
                MP[0]=i+1;
            }else if(str[i]=='b'&&MP[1]!=-1){
                a[i+1]=i+1-MP[1];
                MP[1]=i+1;
            }else if(str[i]=='a'){
                MP[0]=i+1;
                a[i+1]=1;
            }else if(str[i]=='b')
            {
                a[i+1]=1;
                MP[1]=i+1;
            }
        }
        a[n+1]=0;
        da(a,n,n);
        MP[0]=MP[1]=n+1;
        rk[n+1]=-1;
        rk[n+2]=-2;
        for(int i=n-1;i>=0;i--){
            if(str[i]=='a'){
                no[i].a=MP[1]-i,no[i].b=rk[MP[1]+1],no[i].idx=i+1;
                MP[0]=i+1;
            }else {
                no[i].a=MP[0]-i,no[i].b=rk[MP[0]+1],no[i].idx=i+1;
                MP[1]=i+1;
            }
        }
        sort(no,no+n);
        for(int i=0;i<n;i++){
            printf("%d ",no[i].idx);
        }
        puts("");
    }
}
```

# 后缀自动机

```
#include<bits/stdc++.h>

using namespace std;

const int N=200006;
const int maxn=200006;

struct node
{
    int ch[10];int len,fa,left;
    int val;//left表示该状态串出现的最左边的点？
}no[N];

int las,tot;
void add_no(int u,int val)
{
    int p=las,np=las=++tot;
    no[np].len=no[p].len+1;
    for(;p&&!no[p].ch[u];p=no[p].fa)no[p].ch[u]=np;
    if(!p){
        no[np].fa=1;return ;
    }

    int q=no[p].ch[u];//表示对应那个点
    if(no[q].len==no[p].len+1)no[np].fa=q;//表示不存在a|ba|ba这种情况
    else {
        int nq=++tot;
        no[nq]=no[q];//nq表示只+1的结点，且他的父亲还是+n的结点的父亲
        no[nq].len=no[p].len+1;//是要链接长度只+1的结点的
        no[np].fa=no[q].fa=nq;//插入的点是让Len+1的点
        for(;p&&no[p].ch[u]==q;p=no[p].fa)
            no[p].ch[u]=nq;//把原本链接到q
    }
};
//性质:防止忘记:不同子串个数等于dian[las].len-dian[dian[las].fa].len
//当前sta最短的长度为no[no[i].fa].len+1
int n;
int b[maxn],id[maxn];
void sort()
{
    int Len=n;
    // for(int p=1,i=0;i<Len;i++)p=no[p].ch[str[i]-'a'],r[p]++;
    for(int i=1;i<=tot;i++)b[no[i].len]++;//要排序，让长度短的在前面
    for(int i=1;i<=n;i++)b[i]+=b[i-1];
    for(int i=1;i<=tot;i++)id[b[no[i].len]--]=i;
    // for(int i=tot;i>=1;i--)r[no[id[i]].fa]=r[id[i]];
}//拓扑排序.jpg

int main()
{
    int t;cin>>t;int kk=1;
    memset(no,0,sizeof no);
    tot=las=1;
    while(t--){
        string str;
        cin>>str;
        int n=str.length();
        for(int i=0;i<n;i++){
            add_no(str[i]-'0',str[i]-'0');
        }
        
    }
    int ans=0;
    for(int i=2;i<=tot;i++){
            ans=(ans+no[i].val)%2012;
        }
        cout<<ans<<endl;
    
}
```

# 回文自动机

```
#include <bits/stdc++.h>

using namespace std;
const int maxn=1e5+10;
struct PAM
{
    int ch[maxn*2][26],fail[maxn*2],S[maxn*2];
    int n[2],tot,Len[maxn*2],cnt[maxn*2],num[maxn*2];
    int l,r;
    int last[2];
    int newnode(int len)
    {
        for(int i=0;i<26;i++)ch[tot][i]=0;
        Len[tot]=len,fail[tot]=0,cnt[tot]=0,num[tot]=0;
        return tot++;
    }
    void init()
    {
        tot=l=r=0;
        newnode(0),newnode(-1);//1表示左边插入
        fail[0]=1;
        memset(S,-1,sizeof S);
        n[1]=maxn-9,n[0]=maxn-10;//0表示右边的边界，1表示左边边界//
    }
    int getFail(int x,int k)//k=0表示向右+，反之
    {
        while(S[n[k]-(Len[x]+1)*(k?-1:1)]!=S[n[k]]){x=fail[x];}
        return x;
    }
    int ins(int c,int k){
        c-='a';
        S[n[k]+=(k?-1:1)]=c;
        int cur=getFail(k?l:r,k);
        if(!ch[cur][c]){
            int now=newnode(Len[cur]+2);
            fail[now]=ch[getFail(fail[cur],k)][c];
            ch[cur][c]=now;
            num[now]=num[fail[now]]+1;
           
        }
        if(k==1){
            l=ch[cur][c];cnt[l]++;
             if(n[0]-n[1]+1==Len[l]){
                    r=l;
            }
            return num[l];
        }else {
            r=ch[cur][c];cnt[r]++;
            if(n[0]-n[1]+1==Len[r]){
                l=r;
            }
            return num[r];
        }
    }
}pam;


int main()
{
    int n;
    
    while(cin>>n)
    {
        pam.init();
        int all=0;
        for(int i=1;i<=n;i++){
            int a;char b;
            scanf("%d",&a);
            if(a==1||a==2){
                cin>>b;
                all+=pam.ins(b,a==1);
            }else if(a==3){
                printf("%d\n",pam.tot-2);
            }else {
                printf("%d\n",all);
            }
        }
    }
    
}
```

# ac自动机

```
#include <bits/stdc++.h>


using namespace std;
const int N=100006*4;
vector<int> v[N];
struct node
{
    int ch[N][26];
    int fail[N];
    int tot;
    int cnt[N];
    void init(){
        memset(ch[0],0,sizeof ch[0]);
        tot=0;fail[0]=cnt[0]=0;tot++;v[0].clear();
    }
    void ins(char *str)
    {
        int L=strlen(str);
        int rt=0;
        for(int i=0;i<L;i++){
            int c=str[i]-'a';
            if(!ch[rt][c]){
                memset(ch[tot],0,sizeof ch[tot]);
                ch[rt][c]=tot;fail[tot]=0;cnt[tot]=0;tot++;v[tot-1].clear();
            }rt=ch[rt][c];
        }
        cnt[rt]=1;
    }
    void build()
    {
        queue<int> que;
        for(int i=0;i<26;i++)if(ch[0][i])que.push(ch[0][i]),fail[ch[0][i]]=0;
        while(!que.empty())
        {
            int u=que.front();que.pop();
            cnt[u]|=cnt[fail[u]];
            for(int i=0;i<26;i++){
                if(!ch[u][i]){
                    ch[u][i]=ch[fail[u]][i];
                }else {
                    fail[ch[u][i]]=ch[fail[u]][i];
                    que.push(ch[u][i]);
                }
            }
        }
    }
}ac;
char s[N];
int dis[N];
int A[N];
int main()
{
    int n;
    while(~scanf("%d",&n))
    {
        ac.init();
        for(int i=1;i<=n;i++){
            scanf("%s",s);
            ac.ins(s);
        }
        ac.build();
        queue<int> que;
        memset(dis,-1,sizeof dis);
        for(int i=0;i<ac.tot;i++){
            if(ac.cnt[i])que.push(i),dis[i]=0;
            for(int j=0;j<26;j++){
                v[ac.ch[i][j]].push_back(i);
            }
        }
        while(!que.empty()){
            int u=que.front();que.pop();
            for(int i=0;i<v[u].size();i++){
                int nx=v[u][i];
                if(dis[nx]==-1){
                    que.push(nx);dis[nx]=dis[u]+1;
                }
            }
        }

        scanf("%s",s);
        int len=strlen(s);
        int t=0;
        int rt=0;
        printf("%d\n",dis[0]);
        memset(A,0,sizeof A);
        for(int i=0;i<len;i++){
            if(s[i]=='-'){
                if(t)t--;
                printf("%d\n",dis[A[t]]);
            }else {
                rt=ac.ch[A[t]][s[i]-'a'];
                A[++t]=rt;
                printf("%d\n",dis[A[t]]);
            }
        }
    }
   
}
```

# kmp算法

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;
int nxt[405];
char a[4005];
char s[4005];
void gnxt(int len)
{
    int i,j;
    nxt[0]=-1;i=0,j=-1;
    while(i<len)
    {
        if(j==-1||a[i]==a[j]){
            i++;j++;
            nxt[i]=j;
        }else j=nxt[j];
    }
}

char sz[4002][405];
bool kmp(int x,int L)
{
    int i,j;
    i=0;j=0;
    int len=strlen(sz[x]);
    while(i<len&&j<L){
        if(j==-1||sz[x][i]==a[j]){
            i++;j++;
        }else j=nxt[j];
        if(j>=L)return true;
    }
    return false;
}
char ans[4005];
char mins[205];
int main()
{
    int n;
    while(~scanf("%d",&n)&&n)
    {
        ans[0]='\0';
        int minv=0x3f3f3f3f;
        for(int i=1;i<=n;i++){
            scanf("%s",sz[i]);
            int len=strlen(sz[i]);
            if(len<minv){
                strcpy(mins,sz[i]);
                minv=len;
            }
        }
        int Len=minv;
        for(int be=0;be<Len;be++){
            for(int ed=be;ed<Len;ed++){
                strncpy(a,mins+be,ed-be+1);
                a[ed-be+1]='\0';
                gnxt(ed-be+1);
                int flag=1;
                for(int j=2;j<=n;j++){
                    if(!kmp(j,ed-be+1)){
                        flag=0;break;
                    }
                }
                if(flag){
                    int La=strlen(ans),Lb=strlen(a);
                    if(La<Lb)
                    strcpy(ans,a);
                    else if(La==Lb&&strcmp(ans,a)>0){
                        strcpy(ans,a);
                    }
                }
            }
        }
        int L=strlen(ans);
        if(L){
            puts(ans);
        }else {
            puts("IDENTITY LOST");
        }
    }
}
```

# lydon分解

```
#include<iostream>
#include<string>
#include<vector>
using namespace std;

vector<string> duval(string str){
	int i = 0,j,k,n = str.size();
	
	vector<string> ans;
	
	while(i < n){
		k = i;
		j = i + 1;
		while(j < n && str[k] <= str[j]){
			k = str[k] == str[j] ? k + 1 : i;
			j++;
		}
		while(i <= k){
			ans.push_back(str.substr(i,j - k));
			i += j - k;
		}
	}
	return ans;
}

int main(){
	string str;
	cin >> str;
	vector<string> ans = duval(str);
	for(int i = 0;i < ans.size();i++){
		cout << ans[i] << endl;
	}
}

```

# manacher

```
#include<bits/stdc++.h>


using namespace std;
const int maxn=1000006;
int mana[maxn*2];
char a[maxn];
int Len[maxn];
int L,R;
int ANS=0;
void Mana()
{
    int c,r;c=r=-1;
    int n=strlen(a);
    int pos=0;mana[0]='$';
    for(int i=0;i<n;i++){
        mana[++pos]='#';
        mana[++pos]=a[i];
    }
        mana[++pos]='#';mana[pos+1]='\0';
        int ans=0;
        int l;
    for(int i=1;i<=pos;i++){
        if(i<r)Len[i]=min(r-i,Len[2*c-i]);
        else Len[i]=1;
        while(mana[i-Len[i]]==mana[i+Len[i]]&&i-Len[i]>=0)Len[i]++;
        if(i+Len[i]>r){
            r=i+Len[i];
            c=i;
        }
        if(Len[i]-1<=ANS)continue;
        if(Len[i]-1>ANS){
            if(Len[i]+i-1==pos){ANS=Len[i]-1;
                R=1;L=0;
            }
            if(i-Len[i]+1==1){ANS=Len[i]-1;
                R=0;L=1;
            }
        }
    }
}

//性质：是左边的情况为：i-len[i]+1==1,1为可用符号的最小点
//是右边的情况为：i+Len[i]-1==pos,pos为可用符号的最大点
char now[maxn];
char fi[maxn];
char se[maxn];
int main()
{
    int t;
    cin>>t;
    while(t--){
        scanf("%s",now);
        int l=0,r=strlen(now)-1;
        int A,B;
        A=B=0;
        ANS=0;
        L=0,R=0;
        while(l<r){
            if(now[l]==now[r]){
                fi[A++]=now[l];
                se[B++]=now[r];
                l++,r--;
            }else
            {
                 break;
            }
        }
        int z=0;
        
        for(int i=l;i<=r;i++){
            a[z++]=now[i];
        }
        // cout<<"EM"<<endl;
        a[z]='\0';
        Mana();
        for(int i=0;i<A;i++){
            putchar(fi[i]);
        }
        if(L){
            for(int i=l;i<l+ANS;i++){
                putchar(now[i]);
            }
        }else if(R){
            // cout<<"E"<<endl;
            for(int i=r;i>r-ANS;i--){
                putchar(now[i]);
            }
            // cout<<"A"<<endl;
        }
        for(int i=B-1;i>=0;i--){
            putchar(se[i]);
        }
        puts("");
    }
}
```

# 最小表示法

```
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    k++;
  } else {
    sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
    if (i == j) i++;
    k = 0;
  }
}
i = min(i, j);
```

