### 线段树操作，数据小，直接操作就可以

```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn=100004;
struct node
{
	int l,r,minv;
}no[maxn*3];
int a[maxn];
void push_up(int v)
{
	no[v].minv=min(no[v<<1].minv,no[v<<1|1].minv);
}

void update(int v,int pos)
{
	int l=no[v].l,r=no[v].r;
	int mid=(l+r)>>1;
	if(l==r){
		no[v].minv=a[pos];
		return ;
	}
	if(pos>mid){
		update(v<<1|1,pos);
	}else {
		update(v<<1,pos);
	}
	push_up(v);
}

int query(int v,int l,int r)
{
	
	int ll=no[v].l,rr=no[v].r; 
	if(ll==l&&rr==r){
		return no[v].minv;
	}
	int mid=(ll+rr)>>1;
	if(mid>=r){
		return query(v<<1,l,r);
	}else if(mid<l){
		return query(v<<1|1,l,r);
	}else {
		return min(query(v<<1,l,mid),query(v<<1|1,mid+1,r));
	}
}

void build(int v,int l,int r)
{
	no[v].l=l,no[v].r=r;
	if(l==r){
		no[v].minv=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(v<<1,l,mid);
	build(v<<1|1,mid+1,r);
	push_up(v);
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	build(1,1,n);
	for(int i=0;i<m;i++)
	{
		string str;
		cin>>str;
		if(str[0]=='q'){
			int l=0;
			int j;
			for(j=6;j<str.length();j++){
				if(str[j]==',')break;
				l=l*10+str[j]-'0';
			}
			j++;int r=0;
			for(;j<str.length()-1;j++){
				r=r*10+str[j]-'0';
			}
			printf("%d\n",query(1,l,r));
		}else {
			vector<int> tmp;
			int z=0;
			for(int j=6;j<str.length()-1;j++){
				if(str[j]==','){
					tmp.push_back(z);z=0;continue;
				}
				z=z*10+str[j]-'0';
			}
			tmp.push_back(z);
			int temp[100];
		
			for(int j=0;j<tmp.size();j++){
				temp[j]=a[tmp[j]];
			}
			for(int j=0;j<tmp.size();j++){
				a[tmp[j]]=temp[(j+1)%(tmp.size())];
				update(1,tmp[j]);
			}
		}
	}
}
```

