### 题目很难，不过找下规律可以看到的是，每次查找`x+1`大的数字就可以，查找完删除那个数字。

树状数组的二分

```
#include<bits/stdc++.h>

using namespace std;
const int maxn = 100005;
struct node
{
	int l,r;int val;
}no[maxn*3];
void push_up(int v)
{
	no[v].val=no[v<<1].val+no[v<<1|1].val;
}
void build(int v,int l,int r)
{
	no[v].l=l;no[v].r=r;
	if(l==r){
		no[v].val=1;
		return ;
	}
	int mid=(l+r)>>1;
	build(v<<1,l,mid);
	build(v<<1|1,mid+1,r);
	push_up(v);
}

int query(int v,int pos)
{
	int l=no[v].l,r=no[v].r;
	if(l==r)
	{
		no[v].val=0; 
		return r;
	}
	int mid=(l+r)>>1;
	int ans;
	if(pos>no[v<<1].val)ans=query(v<<1|1,pos-no[v<<1].val);//重点。。。 
	else ans=query(v<<1,pos);
	push_up(v);
	return ans;
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		
		build(1,1,n);
		for(int i=0;i<n;i++){
			int x;
			scanf("%d",&x);
			if(i)cout<<" "; 
			cout<<query(1,x+1);
		}
		cout<<endl;
	}
} 
```



```C++
#include<bits/stdc++.h>

using namespace std;

int lowbit(int x)
{
	return x&(-x);
}
int n;
const int maxn=100004;
int sum[maxn];
void add(int pos,int val)
{
	while(pos<=n)
	{
		sum[pos]+=val;
		pos+=lowbit(pos);
	}
}

int num(int po)
{
	int ans=0;
	while(po>=1)
	{
		ans+=sum[po];po-=lowbit(po);
	}
	return ans;
}

int loc(int kth)
{
	int l=1,r=n;
	int ans;
	while(l<=r)
	{
		int numm=num((l+r)>>1);
		
		if(numm>=kth){
			ans =(l+r)>>1;
			r=((l+r)>>1)-1;
		}else if(numm<kth){
			l=((l+r)>>1)+1;
		}
	}
	return ans;
}

int main()
{
	int t ;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			add(i,1);
		}
		for(int i=0;i<n;i++){
			int x;scanf("%d",&x);
			int ans=loc(x+1);
			if(i)cout<<" ";
			cout<<ans;
			add(ans,-1);
		}
		cout<<endl;
	}
}
```

