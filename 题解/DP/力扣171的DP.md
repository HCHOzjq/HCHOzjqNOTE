###

第四题

有意思的dp

![image-20200126222418084](C:\Users\zjq\AppData\Roaming\Typora\typora-user-images\image-20200126222418084.png)

> 示例 1：
>
> 输入：word = "CAKE"
> 输出：3
> 解释： 
> 使用两根手指输入 "CAKE" 的最佳方案之一是： 
> 手指 1 在字母 'C' 上 -> 移动距离 = 0 
> 手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 
> 手指 2 在字母 'K' 上 -> 移动距离 = 0 
> 手指 2 在字母 'E' 上 -> 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 
> 总距离 = 3

    
    };class Solution {
    public:
    int get(int a,int b)
    {
       int ax=a%6;
       int ay=a/6;
       int bx=b%6;
       int by=b/6;
       return abs(ax-bx)+abs(ay-by);
    }
    int dp[300][26][26];
    int dis[26][26];
    int minimumDistance(string word) {
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                dis[i][j]=get(i,j);
            }
        }
        
        memset(dp,0x3f,sizeof dp);
        for(int i=0;i<26;i++){
            dp[0][word[0]-'A'][i]=dp[0][i][word[0]-'A']=0;
        }
        for(int i=1;i<word.size();i++){
            int now=word[i]-'A';
            int prev=word[i-1]-'A';
            int val=dis[now][prev];
            for(int j=0;j<26;j++){
                dp[i][now][j]=min(dp[i][now][j],dp[i-1][prev][j]+val);
                dp[i][j][now]=min(dp[i][j][now],dp[i-1][j][prev]+val);
                if(j==prev){
                    for(int k=0;k<26;k++){
                        dp[i][now][j]=min(dp[i][now][j],dp[i-1][k][j]+dis[k][now]);
                        dp[i][j][now]=min(dp[i][j][now],dp[i-1][j][k]+dis[k][now]);
                    }
                }
            }
        }
        int n=word.size();
        int ans = *min_element(dp[n - 1][0], dp[n - 1][0] + 26 * 26);
        return ans;
    
    }
    };
```
class Solution {
public:

    int get(int a,int b)
    {
       int ax=a%6;
       int ay=a/6;
       int bx=b%6;
       int by=b/6;
       return abs(ax-bx)+abs(ay-by);
    }
    int dp[300][26];
    int dis[26][26];
    int minimumDistance(string word) {
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                dis[i][j]=get(i,j);
            }
        }
        
        memset(dp,0x3f,sizeof dp);
        for(int i=0;i<26;i++){
            dp[0][i]=0;
        }
        for(int i=1;i<word.size();i++){
            int now=word[i]-'A';
            int prev=word[i-1]-'A';
            int val=dis[now][prev];
            for(int j=0;j<26;j++){
                dp[i][j]=min(dp[i][j],dp[i-1][j]+val);
                if(prev==j){
                    for(int k=0;k<26;k++)
                    dp[i][j]=min(dp[i][j],dp[i-1][k]+dis[k][now]);
                }
            }
        }
        int n=word.size();
        int ans = *min_element(dp[n - 1], dp[n - 1] + 26);
        return ans;

    }
};
```

