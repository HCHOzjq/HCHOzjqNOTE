### 发现板子有点奇怪。。。

直接枚举每个管子上面的点和下面的点。

求线段要用规范相交，因为端点相交在这里无所谓。

好迷。。。明天再来看看，把题解解决了。

- 光线可以通过的最长距离肯定是一个上端点和一个下端点之间的直线。
- 经过端点可以当作是通过那个地方，

```C++
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

const double eps=1e-8;
const int maxn=100005;
int dcmp(double a)//判断两数字大小 
{
	double ans=a;
	if(ans>eps)return 1;
	else if(fabs(ans)>eps)return -1; 
	else return 0;
}

struct point 
{
	double x,y;
	point(){}
	point(double a,double b):x(a),y(b){
		
	}
	point operator-(const point a)const {
		return point(x-a.x,y-a.y);
	}
}down[maxn],up[maxn];

double xmul(const point a,const point b)
{
	return a.x*b.y-a.y*b.x;
}

struct line
{
	point s,e;
	line(){
	}
	line(double a,double b,double c,double d):s(a,b),e(c,d){
	}
	line(point a,point b):s(a),e(b){
		
	}
	pair<int,point> operator&(const line &b)const
	{
		point res=s;
		if(dcmp(xmul(s-e,b.s-b.e))==0){
			if((xmul(s-b.e,b.s-b.e))==0)
			return make_pair(0,res);//chonhe
			else make_pair(1,res); //pingxing
		}
		point u=s-b.s;
		point w=b.e-b.s;
		point v=e-s;
		double t=xmul(w,u)/xmul(v,w);
		res.x=res.x+t*(e.x-s.x);
		res.y=res.y+t*(e.y-s.y);
		
		return make_pair(2,res);
	} 
};

bool judge(line a,line b)//非规范相交，端点可以算的情况 
{
	/*
	if(min(a.s.x,a.e.x)>max(b.s.x,b.e.x))return false;
	if(min(b.s.x,b.e.x)>max(a.s.x,a.e.x))return false;
	if(min(a.s.y,a.e.y)>max(b.s.y,b.e.y))return false;
	if(min(b.s.y,b.e.y)>max(a.s.y,a.e.y))return false;&&xmul(b.e-b.s,a.s-b.s)*xmul(b.e-b.s,a.e-b.s)<=0
	*/
	if(xmul(a.e-a.s,b.s-a.s)*xmul(a.e-a.s,b.e-a.s)<=0){
		return true;
	}else return false;
	
}

int main()
{
	int n;
	int p,l;
	
	while(~scanf("%d",&n)&&n)
	{
		for(int i=0;i<n;i++)
		{
			double a,b;
			scanf("%lf%lf",&a,&b);
			up[i]=point(a,b);
			down[i]=point(a,b-1);
		}
		double ans=up[0].x;
		
		int flag=0;
		for(int i=0;i<n&&!flag;i++)
		{
			for(int j=i+1;j<n&&!flag;j++)
			{	
				int k;
				for(k=0;k<n;k++){
					if(!judge(line(up[i],down[j]),line(up[k],down[k]))){
						break;
					}
				}
				if(k>=n){
					flag=1;
					break;
				}
				if(k>max(i,j)){
					
				pair<int,point> pr;
				if(judge(line(up[i],down[j]),line(up[k-1],up[k])))
				{
				pr=(line(up[i],down[j])&line(up[k-1],up[k]));
				ans=max(ans,pr.second.x);	
				}
				if(judge(line(up[i],down[j]),line(down[k-1],down[k])))
				{
				pr=(line(up[i],down[j])&line(down[k-1],down[k]));
				ans=max(ans,pr.second.x);	
				}
			
				}
				
				for(k=0;k<n;k++){
					if(!judge(line(up[j],down[i]),line(up[k],down[k]))){
						break;
					}
				}
				
				if(k>=n){
					flag=1;
					break;
				}
				if(k>max(i,j)){
				pair<int,point> pr;
				if(judge(line(up[j],down[i]),line(up[k-1],up[k])))
				{
					pr=(line(up[j],down[i])&line(up[k-1],up[k]));
					ans=max(ans,pr.second.x);
				}
				if(judge(line(up[j],down[i]),line(down[k-1],down[k]))) 
				{
				pr=(line(up[j],down[i])&line(down[k-1],down[k]));
				ans=max(ans,pr.second.x);		
				}
				}
			}
		}
		
		if(!flag)
		printf("%.2lf\n",ans);
		else {
			printf("Through all the pipe.\n");
		}
	}

}
```

