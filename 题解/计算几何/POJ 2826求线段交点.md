### 求两条线段组成的图形可以接住的最大雨量。

要排除以下几种情况：

- 线段平行与x轴
- 两条线段不相交
- 两条线段形成

#### 然后就是交点的计算了，直接套模板吧，这里交点是从蓝书中套的。

POJ G++交了给wa掉了emm，就c++过了。

![img](https://images0.cnblogs.com/blog/303230/201307/16011012-28493212a11d4519bd83b3584c0ac4c5.jpg)

```C++
#include<stdio.h>
#include<math.h>
#include<algorithm>

using namespace std;

const double eps=1e-8;
const int maxn=100005;
int dcmp(double a)//判断两数字大小 
{
	double ans=a;
	if(ans>eps)return 1;
	else if(fabs(ans)>eps)return -1; 
	else return 0;
}

struct point 
{
	double x,y;
	point(){}
	point(double a,double b):x(a),y(b){
		
	}
	point operator-(const point a)const {
		return point(x-a.x,y-a.y);
	}
}p[maxn];

double xmul(const point a,const point b)
{
	return a.x*b.y-a.y*b.x;
}

struct line
{
	point s,e;
	line(double a,double b,double c,double d):s(a,b),e(c,d){
	}
	line(point a,point b):s(a),e(b){
		
	}
	pair<int,point> operator&(const line &b)const
	{
		point res=s;
		if(dcmp(xmul(s-e,b.s-b.e))==0){
			if((xmul(s-b.e,b.s-b.e))==0)
			return make_pair(0,res);
			else make_pair(1,res); 
		}
		point u=s-b.s;
		point w=b.e-b.s;
		point v=e-s;
		double t=xmul(w,u)/xmul(v,w);
		res.x=res.x+t*(e.x-s.x);
		res.y=res.y+t*(e.y-s.y);
		return make_pair(2,res);
	} 
};

bool judge(line a,line b)//非规范相交，端点可以算的情况 
{
	if(min(a.s.x,a.e.x)>max(b.s.x,b.e.x))return false;
	if(min(b.s.x,b.e.x)>max(a.s.x,a.e.x))return false;
	if(min(a.s.y,a.e.y)>max(b.s.y,b.e.y))return false;
	if(min(b.s.y,b.e.y)>max(a.s.y,a.e.y))return false;
	
	if(xmul(a.e-a.s,b.s-a.s)*xmul(a.e-a.s,b.e-a.s)<=0&&xmul(b.e-b.s,a.s-b.s)*xmul(b.e-b.s,a.e-b.s)<=0){
		return true;
	}else return false;
	
}


int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		double a,b,c,d;
		scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
		line l1(a,b,c,d);
		scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
		line l2(a,b,c,d);
		if(l1.s.y<l1.e.y)swap(l1.s,l1.e);
		if(l2.s.y<l2.e.y)swap(l2.s,l2.e);
		if(dcmp(l1.s.y-l1.e.y)==0||dcmp(l2.s.y-l2.e.y)==0){
			printf("0.00\n");
			continue;
		}
		if(judge(l1,l2)==0){
			printf("0.00\n");
			continue;
		}
		if(judge(line(l1.s,point(l1.s.x,100000)),l2))
		{
			printf("0.00\n");
			continue;
		}
		if(judge(line(l2.s,point(l2.s.x,100000)),l1))
		{
			printf("0.00\n");
			continue;
		}
		
		pair<int,point> pr;
		pr=l1&l2;
		point p=pr.second;
		double ans1;
		pr=l1 & (line(point(100000,l2.s.y),l2.s));
		point p1=pr.second;
		ans1=fabs(xmul(l2.s-p,p1-p))/2;
		double ans2;
		pr=l2 & ((line(point(100000,l1.s.y),l1.s)));
		point p2=pr.second;
		ans2=fabs(xmul(l1.s-p,p2-p))/2;
		printf("%.2f\n",min(ans1,ans2));
	}
} 
```

