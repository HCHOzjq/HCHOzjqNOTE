题目要求凸包？？

找到最左下的点为第一个点，然后每次对后边的点进行极角排序。

```C++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

struct point
{
	int id;
	double x,y;
	point(){
		
	} 
	point(int c,double a,double b):x(a),y(b),id(c){
		
	}
}p[100004];

double dis(point a,point b)
{
	return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

point operator-(point &a,point &b){
	return point(-1,a.x-b.x,a.y-b.y);
}

double xmul(point a,point b)
{
	return a.x*b.y-a.y*b.x;
}
point init;
bool cmp(point a,point b)
{
	double ans=xmul(a-init,b-init);
	if(ans>0)return true;
	else if(ans<0)return false;
	else return dis(a,init)<dis(b,init);
}

int main()
{
	int t;
	scanf("%d",&t);
	
	while(t--)
	{
		int n;
		scanf("%d",&n);
		init.id=0;
		init.x=1e10;
		init.y=1e10;
		for(int i=0;i<n;i++)
		{
			int a;double b,c;
			scanf("%d%lf%lf",&a,&b,&c);
			p[i]=point(a,b,c);
			if(p[i].y<init.y){
				init=p[i];
			}else if(p[i].y==init.y&&p[i].x<init.x){
				init=p[i];
			}else {
				continue;
			}
		}
		vector<int> ans;
		swap(p[init.id-1],p[0]);
		ans.push_back(init.id);
		
		for(int i=1;i<n;i++)
		{
			sort(p+i,p+n,cmp);
			init=p[i];
			ans.push_back(p[i].id);
		}
		cout<<n<<" ";
		for(int i=0;i<ans.size();i++){
			if(i)cout<<" ";
			cout<<ans[i];
		}
		cout<<endl;
	}
}
```

