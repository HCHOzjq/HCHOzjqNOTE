

求矩形与一条线段是不是相交。

一开始直接用跨立实验，过不了，之后加了快速排序就过了，不知道为什么?//以后判断线段还是把快速排斥也+了吧。

### 加了快速排斥之后，端点也可以算作是相交。

```C++
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
int vis[100005];
using namespace std;
struct point
{
	double x,y;
	point(){} 
	point(double xx,double yy){
		x=xx;y=yy;
	}
	point operator-(const point b)const {
		return point(x-b.x,y-b.y);
	}
	double xmul(point a){
		return x*a.y-y*a.x;
	}
};

struct edge
{
	point s,e;
	edge(){} 
	edge(double a,double b,double c,double d):s(a,b),e(c,d){
	}
	bool cross(edge a){
		if(min(s.x,e.x)>max(a.s.x,a.e.x)
		 ||min(a.s.x,a.e.x)>max(s.x,e.x)
		 ||min(s.y,e.y)>max(a.s.y,a.e.y)
		 ||min(a.s.y,a.e.y)>max(s.y,e.y))return 0;
		 
		 return ((e-s).xmul(e-a.s)*(e-s).xmul(e-a.e)<=0&&
		 		(a.e-a.s).xmul(a.e-s)*(a.e-a.s).xmul(a.e-e)<=0);
	}
};
using namespace std;
int main()
{
	int t;scanf("%d",&t);
	while(t--)
	{
		double a,b,c,d;
		scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
		edge e=edge(a,b,c,d);
		scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
		if(a>c)swap(a,c);
		if(b>d)swap(b,d);
		edge e1=edge(a,b,c,b);
		edge e2=edge(c,b,c,d);
		edge e3=edge(c,d,a,d);
		edge e4=edge(a,d,a,b);
		int ok=0;
		if(e.s.x<=c&&e.s.x>=a&&e.s.y>=b&&e.s.y<=d){
			ok=1;
		}
		if(e.e.x<=c&&e.e.x>=a&&e.e.y>=b&&e.e.y<=d){
			ok=1;
		}
		if(e1.cross(e)||e2.cross(e)||e3.cross(e)||e4.cross(e)){
			ok=1;
		}
		if(ok){
			cout<<"T"<<endl;
		}else {
			cout<<"F"<<endl;
		}
	}
}
```

