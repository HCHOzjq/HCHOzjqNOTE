题目给出一个矩阵，矩阵有多列。每列有4个端点![img](https://vj.z180.cn/645e625e62d18e2c5da4d99ab0713357?v=1579628377)

如上图，左点到右点的最短路径。

将每个点都添加起来（包括左右两个5的点），然后逐步计算每两个点是不是可以连接（无规范相交）。

规范相交也就是除了端点之外有相交。

线段相交得要判断两个边。也就是a边和b边判断一次，然后b边和a边判断一次。

__判断__是不是规范相交

```C++
bool cross(L l)
	{
		double a=(e-s).CP(l.s-s);
		double b=(e-s).CP(l.e-s);
		double c=(l.e-l.s).CP(s-l.s);
		double d=(l.e-l.s).CP(e-l.s);
		if(a*b<0&&c*d<0)return true;
		return false;
	}
```

这题有坑就是输出要用`%f`

```C++
#include<iostream>
#include<cstdio>
#include<cmath>
typedef long long ll;
using namespace std;

const int maxn=105;
double tu[maxn][maxn];
const double INF=1e9;
const double eps=1e-9;
struct P
{
	double x,y;
	P(){
	}
	P(double a,double b):x(a),y(b){
	}
	P operator-(const P& p)const{
		return P(x-p.x,y-p.y);
	}
	double CP(P p){
		return x*p.y-y*p.x;
	}
}p[maxn];

struct L
{
	P s,e;
	L(P a,P b){
		s=a;e=b;
	}
	bool cross(L l)
	{
		double a=(e-s).CP(l.s-s);
		double b=(e-s).CP(l.e-s);
		double c=(l.e-l.s).CP(s-l.s);
		double d=(l.e-l.s).CP(e-l.s);
		if(a*b<0&&c*d<0)return true;
		return false;
	}
};

double dis(P a,P b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
int n;
double cal(int a,int b)
{
	L l1(p[a],p[b]);
	for(int i=0;i<n;i++){
		P p1(p[i*4+1].x,0);
		P p2=p[i*4+1];
		if(l1.cross(L(p1,p2)))return INF;
		p1=p[i*4+2];
		p2=p[i*4+3];
		if(l1.cross(L(p1,p2)))return INF;
		p1=p[i*4+4];
		p2=P(p[i*4+1].x,10);
		if(l1.cross(L(p1,p2)))return INF;
	}
	return dis(p[a],p[b]);
}

int main()
{
	while(~scanf("%d",&n)&&n!=-1)
	{
		p[0].x=0;p[0].y=5;
		for(int i=0;i<n;i++){
			double a,b,c,d,e;
			scanf("%lf%lf%lf%lf%lf",&a,&b,&c,&d,&e);
			p[4*i+1].x=a;p[i*4+1].y=b;
			p[i*4+2].x=a;p[i*4+2].y=c;
			p[i*4+3].x=a;p[i*4+3].y=d;
			p[i*4+4].x=a;p[i*4+4].y=e;
		} 
		p[4*n+1].x=10,p[4*n+1].y=5;
		for(int i=0;i<=4*n+1;i++){
			tu[i][i]=0;
			for(int j=i+1;j<=4*n+1;j++){
				tu[i][j]=tu[j][i]=cal(i,j);
			}
		}
		for(int i=0;i<=4*n+1;i++){
			for(int j=0;j<=4*n+1;j++){
				for(int z=0;z<=4*n+1;z++){
					tu[j][z]=min(tu[j][z],tu[j][i]+tu[i][z]);
				}
			}
		}
		printf("%.2f\n",tu[0][4*n+1]);
		
	}
}

```
