### POJ 2318

- 叉积的运算，模板题

题目用板子分割一个长方体为多个格子，求每个格子有多少个toy。

`叉积a,b：x1*y2-x2*y1`如果结果小于0，a在b的逆时针，反之，在顺时钟。

```C++
#include<iostream>
#include<cstring>
using namespace std;
int ans[5005];
int xmul(int x1,int y1,int x2,int y2){
	return (x1*y2)-y1*x2;
}
const int maxn=5005;
int t[maxn],u[maxn];

int main()
{
	int n,m,x1,y1,x2,y2;
	
	while(cin>>n&&n)
	{
		cin>>m>>x1>>y1>>x2>>y2;
		memset(ans,0,sizeof ans);
		for(int i=1;i<=n;i++){
			cin>>t[i]>>u[i];
		}
		
		for(int i=1;i<=m;i++){
			int a,b;cin>>a>>b;
			int j;
			for(j=1;j<=n;j++){
				if(xmul(a-u[j],b-y2,t[j]-u[j],y1-y2)<=0)break;
			}
			ans[j]++;
		}
		for(int i=1;i<=n+1;i++){
			cout<<i-1<<": "<<ans[i]<<endl;
		}
		cout<<endl;
	}
} 
```

### POJ 2318

另外一道题要注意输出和先排序，其他和上面题目差不多

QWQ，好好学英语了。

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int ans[5005];
int xmul(int x1,int y1,int x2,int y2){
	return (x1*y2)-y1*x2;
}
const int maxn=5005;
int t[maxn],u[maxn];
struct node
{
	int x,y;
	bool operator<(const node a)const {
		if(x==a.x)return y<a.y;
		return x<a.x; 
	} 
}no[maxn];
int num[maxn];
int main()
{
	int n,m,x1,y1,x2,y2;
	
	while(cin>>n&&n)
	{
		cin>>m>>x1>>y1>>x2>>y2;
		memset(ans,0,sizeof ans);
		memset(num,0,sizeof num);
		for(int i=1;i<=n;i++){
			cin>>no[i].x>>no[i].y;
		}
		sort(no+1,no+n+1);
		
		for(int i=1;i<=m;i++){
			int a,b;cin>>a>>b;
			int j;
			for(j=1;j<=n;j++){
				if(xmul(a-no[j].y,b-y2,no[j].x-no[j].y,y1-y2)<=0)break;
			}
			ans[j]++;
		}
		for(int i=1;i<=n+1;i++){
			if(ans[i]){
				num[ans[i]]++;
			}
		}cout<<"Box"<<endl;
		for(int i=0;i<2000;i++){
			if(num[i])cout<<i<<": "<<num[i]<<endl;
		}
	}
} 
```

