### E题



### F题

在一棵树中，求三个点，使得三个点相互的距离最大。

题解，显然可知两个点肯定为树的直径，另外一个点就嘚求一下
$$
\sum_{i=1}^{i=n}max(dis1[pos]+dis2[pos]);
$$
也就是从两个直径出发找一个点使得它距离到两个端点距离最大。然后将三点三路径相加除以2就可得距离。

```C++
#include<bits/stdc++.h>

using namespace std;

struct edge
{
	int u,v,next;
}e[4*100005];
int tmp1[200005],tmp2[200005];
int cnt=0;
int head[200005];
void add_edge(int u,int v)
{
	e[cnt].u=u;e[cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt++;
}
int pos;
int dis[200005];
void bfs(int x)
{
	queue<int>que;
	memset(dis,0x3f,sizeof dis);
	dis[x]=0;
	que.push(x);
	while(!que.empty())
	{
		int u=que.front();que.pop();
		for(int i=head[u];i!=-1;i=e[i].next)
		{
			int v=e[i].v;
			if(dis[v]>dis[u])
			{
				dis[v]=dis[u]+1;
				pos=v;
				que.push(v);
			}
		}	
	} 
	
}

int main()
{
	int n;
	scanf("%d",&n);
	memset(head,-1,sizeof head);
	for(int i=0;i<n-1;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add_edge(a,b);
		add_edge(b,a);
	}
	bfs(1);
	int p1=pos;
	bfs(p1);
	int p2=pos;
	//cout<<p1<<" "<<p2<<endl;
	for(int i=1;i<=n;i++){
		tmp1[i]=dis[i];
	}
	bfs(p2);
	for(int i=1;i<=n;i++){
		tmp2[i]=dis[i];
	}
	pos=0;
	for(int i=1;i<=n;i++){
		if(tmp1[i]+tmp2[i]>tmp1[pos]+tmp2[pos]&&i!=p1&&i!=p2){
			pos=i;
		}
	}
	int ans=(tmp1[p2]+tmp1[pos]+tmp2[pos])/2;
	cout<<ans<<endl;
	cout<<p1<<" "<<p2<<" "<<pos<<endl; 
} 
```

