

### 并查集，做了三四个钟头吧

暴力枚举每一个判断是不是裁判。枚举的时候不能将裁判加入并查集中，如果加入后无冲突就表示这个是裁判。

错点是对向量的不理解导致联合的时候搞错值了

```C++
#include<iostream>
#include<cstdio>


using namespace std;

int fa[500*10];
int val[500*10];
int v[500*10],u[500*10];char ch[500*10];
int get(int x)
{
	if(x==fa[x])return x;
	else{
		int t=get(fa[x]);
		val[x]=(val[x]+val[fa[x]])%3;
		return fa[x]=t;
	}
}

bool unit(int u,int v,int w)
{
	int x=get(u),y=get(v);
	if(x==y){
		if((val[u]-val[v]+3)%3!=w)return false;
		else return true;
	}else {
		fa[x]=y;
		val[x]=(val[v]-val[u]+w+3)%3;
		return true;
	}
}

int main()
{
	int n,m;
	while(~scanf("%d%d",&n,&m))
	{
		for(int i=0;i<m;i++){
			scanf("%d%c%d",&v[i],&ch[i],&u[i]);
		}
		int flag=0;int md=0;
		int tot;tot=0;
		int anss,ansi;
		anss=ansi=0;
		for(int i=0;i<n;i++){
			for(int j=0;j<=n;j++){
				fa[j]=j;
				val[j]=0;
			}
			
			flag=0;
			for(int j=0;j<m;j++){
		
				if(v[j]==i||u[j]==i)continue;
				int w;
				if(ch[j]=='='){
				w=0;
				}else if(ch[j]=='>'){
					w=1;
				}else if(ch[j]=='<'){
					w=2;
				}
				
				if(!unit(v[j],u[j],w)){
					flag=1;
					md=max(md,j+1);
					break;
				}
			}
			if(flag==0){
			tot++;
			ansi=i;
			}
		}
		if(tot==0){
			cout<<"Impossible"<<endl;
		}else if(tot>1){
			cout<<"Can not determine"<<endl;
		}else {
			printf("Player %d can be determined to be the judge after %d lines\n",ansi,md);
		}
	}
}
```

