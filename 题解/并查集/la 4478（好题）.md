### 怎么说呢，很好的并查集题目

要找到一个根可以让那些真实纯在的点可以确立其父节点，异或操作算是正常。

然后如何判断能不能找到，就得看那个结点所在的根节点访问次数是不是为偶数，如果是偶数就说明可以异或，如果不是偶数得看是不是为值确定的点。在每次判断值确定与否的时候要先进行找父节点操作。

```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn=21000+20;
int fa[maxn];
int val[maxn];
int tim[maxn];

int get(int x)
{
	if(x==fa[x])return x;
	else {
		int t=fa[x];
		fa[x]=get(fa[x]);
		val[x]^=val[t];
		return fa[x];
	}
}

bool unit(int u,int v,int w)
{
	int r1=get(u),r2=get(v);
	if(r1==r2){
		if((val[u]^val[v])!=w)return 0;
		else return 1;
	}
	if(r1==maxn-2)swap(r1,r2);
	fa[r1]=r2;
	val[r1]=val[u]^val[v]^w;
	return 1;
}

int main()
{
	int n,m;int cas=1;
	while(~scanf("%d%d",&n,&m)&&n+m)
	{
		printf("Case %d:\n",cas++);
		for(int i=0;i<=n+1;i++){
			fa[i]=i;
			val[i]=0;
			tim[i]=0;
		}
		fa[maxn-2]=maxn-2;
		val[maxn-2]=0;
		int err=0;
		int fact=0;
		for(int i=0;i<m;i++)
		{
			char str[10];
			scanf("%s",&str);
			if(str[0]=='I'){
				char ju[100];
				fact++;
				gets(ju);
				int u,v,w;
				int d=sscanf(ju,"%d %d %d",&u,&v,&w);
				if(err)continue;
				if(d==2)w=v,v=maxn-2;
					if(!unit(u,v,w)){
					printf("The first %d facts are conflicting.\n",fact);
					err=1;
					}
			}else {
				int k;scanf("%d",&k);
				int tmp=0;
				int a[20];
				for(int j=0;j<k;j++){
					scanf("%d",&a[j]);
					if(err)continue;
					
					int r=get(a[j]);
					tmp^=val[a[j]];
					a[j]=r;
					tim[r]=tim[r]^1;
				}
				if(err)continue;
				int flag=0;
				for(int j=0;j<k;j++){
					if(tim[a[j]]){
						if(fa[a[j]]==maxn-2){
							continue;
						}else {
						flag=1;
						}
						tim[a[j]]=0;
					}
				}
				
				if(!flag){
					printf("%d\n",tmp);
				}else {
					printf("I don't know.\n");
				}
			}
		}	puts(""); 
	}
} 
```

