给出一些串，求一定长度内的字符串不包含这些串的情况。字符范围为26

- 用总的个数减去包含这些串的个数。

- 矩阵快速幂求状态到状态之间的次数，最后将各种状态累加起来
- 最多6个单词，每个长度为5，所以状态最多为30.
- 就先放个板子在这里，以后自动机直接套用了。。。（还可以优化，具体忘了）
- 矩阵相乘可求多项式？？好像是可以
- 矩阵相乘多少次就可以求多长的串。

```C++
#include<bits/stdc++.h>

using namespace std;
const int num=6+10;
const int size=5+10;

struct Matrix
{
	unsigned long long mat[40][40];
	int n;
	Matrix(){}
	Matrix(int nn)
	{
		n=nn;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				mat[i][j]=0;
			}
		}
	}
	Matrix operator*(const Matrix &ant)const{
		Matrix res=Matrix(n);
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				for(int k=0;k<n;k++){
					res.mat[j][k]+=(mat[j][i]*ant.mat[i][k]);
				}
			}
		}
		return res;
	}
};

unsigned long long pow_m(unsigned long long a,int n)
{
	unsigned long long ret=1;
	unsigned long long tmp=a;
	while(n)
	{
		if(n&1)ret*=tmp;
		tmp*=tmp;
		n>>=1;	
	}
	return ret;
}

Matrix pow_mat(Matrix a,int n)
{
	Matrix ret(a.n);
	for(int i=0;i<a.n;i++){
		ret.mat[i][i]=1;
	}
	Matrix tmp=a;
	while(n)
	{
		if(n&1)ret=ret*tmp;
		tmp=tmp*tmp;
		n>>=1;	
	}
	return ret;
}

struct AC
{
	int ch[num*size][26];
	int sz;
	int fa[num*size];
	int val[num*size];
	void init()
	{
		sz=1;
		memset(ch[0],-1,sizeof ch[0]);
		memset(fa,0,sizeof fa);
	}
	int idx(char ch)
	{
		return ch-'a';
	}
	void insert(string str)
	{
		int root=0;
		int len=str.length();
		for(int i=0;i<len;i++){
			int u=idx(str[i]);
			if(-1==ch[root][u]){
				memset(ch[sz],-1,sizeof ch[sz]);
				ch[root][u]=sz; 
				val[sz]=0;sz++;
			}
			root=ch[root][u];
		}
		val[root]=1;
	}
	void getfail()
	{
		queue<int>que;
		int root=0;
		for(int i=0;i<26;i++){
			if(-1!=ch[root][i]){
				fa[ch[root][i]]=root;
				que.push(ch[root][i]);
			}else {
				ch[root][i]=root;
			}
		} 
		while(!que.empty())
		{
			int u=que.front();que.pop();
			for(int i=0;i<26;i++){
				if(-1!=ch[u][i]){
					fa[ch[u][i]]=ch[fa[u]][i];	
					que.push(ch[u][i]);		
				}else {
					ch[u][i]=ch[fa[u]][i];
				}
				val[ch[u][i]]|=val[fa[ch[u][i]]];
			}
		}
	}
	
	Matrix getMatrix()
	{
		Matrix ret=Matrix(sz+1);
		for(int i=0;i<sz;i++){
			for(int j=0;j<26;j++){
				if(val[ch[i][j]]==0){
					ret.mat[i][ch[i][j]]++;
				}
			}
		}
		for(int i=0;i<sz+1;i++){
			ret.mat[i][sz]=1;
		}
		return ret;
	}
    void debug()
    {
        for(int i = 0;i < sz;i++)
        {
            printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fa[i],val[i]);
            for(int j = 0;j < 26;j++)
                printf("%2d",ch[i][j]);
            printf("]\n");
        }
    }
}ac;

int main()
{
	int n,m;
	while(~scanf("%d%d",&n,&m))
	{
		ac.init();
		for(int i=1;i<=n;i++){
			string str;cin>>str;
			ac.insert(str);
		}
		ac.getfail();
		//ac.debug();
		Matrix mm=ac.getMatrix();
		mm=pow_mat(mm,m);
		unsigned long long ans=0;
		for(int i=0;i<mm.n;i++){
			ans+=mm.mat[0][i];
		}
		ans--;
		Matrix t(2);
		t.mat[0][0]=26;
		t.mat[1][0]=t.mat[1][1]=1;
		unsigned long long anss=0;
		t=pow_mat(t,m);
		anss=t.mat[0][0]+t.mat[1][0];anss--;
		
		cout<<anss-ans<<endl;
	}
	
```

