```C++
#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;
const int N=200005;
int mx[N],mi[N];
int sum[N];
char str[N];
struct PAM
{
	#define KIND 26
	int tire[N][KIND],fail[N],S[N],num[N],cnt[N],Len[N];
	int n,last,tot;
	int newnode(int l){
		mx[tot]=0;
		mi[tot]=1e8;
		for(int i=0;i<KIND;i++)tire[tot][i]=0;
		 
		cnt[tot]=num[tot]=0,Len[tot]=l;
		return tot++;
	}
	
	void init()
	{
		n=last=tot=0;
		newnode(0);newnode(-1);
		//memset(tire,0,sizeof tire);
		memset(S,0,sizeof S);
		fail[0]=1;S[0]=-1;
		
		memset(sum,0,sizeof sum);
	}
	
	int getfail(int x){
		while(S[n]!=S[n-Len[x]-1])x=fail[x];
		return x;
	}
	
	int insert(int c,int pos){
		c-='a';
		S[++n]=c;
		int cur=getfail(last);
//		cout<<"CUR"<<cur<<endl;
//		cout<<cur<<" "<<c<<endl;
//		cout<<"TIR"<<tire[cur][c]<<endl; 
		if(!tire[cur][c]){
			int now=newnode(Len[cur]+2); 
			fail[now]=tire[getfail(fail[cur])][c];
			tire[cur][c]=now;
			num[now]=num[fail[now]]+1;
		}
		last=tire[cur][c];
		mx[last]=max(mx[last],pos);
		mi[last]=min(mi[last],pos);
		cnt[last]++;
		return num[last];
	}
	
	void count()
	{
		for(int i=tot-1;i>=2;i--){
			cnt[fail[i]]+=cnt[i];
			mx[fail[i]]=max(mx[fail[i]],mx[i]);
			mi[fail[i]]=min(mi[fail[i]],mi[i]);
			//fail指针的含义是，这个字符前面的最长后缀，指的是那一块//如果比他短的的最左最右可以由比他长的最左最右绝对，不过好像没有什么差别？ 
			//fail和普通的是不同串，但是fail被包含于普通串中，so... 
			if(mi[i]>=mx[i]-Len[i]+1){
				sum[mx[i]-Len[i]+1]+=1;
				sum[mi[i]+1]-=1;
			}
		}
	}
}pam;
char mana[N];
int len;
int P[N];
void manacher()
{
	mana[0]='#';
	mana[1]='$';
	int pos=2;
	int c=-1,r=-1;
	for(int i=0;i<len;i++){
		mana[pos++]=str[i];
		mana[pos++]='$';
	}
	mana[pos]='!';
	for(int i=1;i<pos;i++){
		if(i<r)P[i]=min(r-i,P[2*c-i]);
		else P[i]=1;
		
		while(mana[i+P[i]]==mana[i-P[i]])P[i]++;
		
		if(P[i]+i>r){
			r=P[i]+i;
			c=i;
		} 
	}
}

int main()
{
	int t;cin>>t;
	while(t--){
		cin>>str;
		len=strlen(str);
		pam.init();
		for(int i=0;i<len;i++){
			pam.insert(str[i],i+1);
		}
		pam.count();
		manacher();
		int ans=0,cnt=0;
		//cout<<pam.tot<<endl;
		for(int i=1;i<=len;i++){
			sum[i]+=sum[i-1];
			int nn=pam.tot-2-sum[i]+(P[i*2]-2)/2+1;//(P[i*2]-2)/2+1----??-2的原因是长度再减去中间那个，然后/2是因为有两边+1是因为那个长度本身 
			if(nn>ans){
				ans=nn;
				cnt=1;
			}else if(nn==ans){
				cnt++;
			}
		} 
		cout<<ans<<" "<<cnt<<endl;
	}
}
```

### 5. [iChandu](https://codeforces.com/gym/100889/problem/I)