```C++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int maxn=2e6+100;
char s[maxn*2];
char mana[maxn*2];
int str[maxn*2];
int P[maxn*2];
int tot;
bool pre[maxn*2],suf[maxn*2];
void manacher(int ss,int ee)
{
	int r,c;
	mana[0]='$';
	mana[1]='#';
	int len=ee-ss;
	c=r=-1;
	int pos=2;
	for(int i=ss;i<ee;i++)
	{
		pre[i]=false,suf[i]=false;
		mana[pos++]=s[i];
		mana[pos++]='#';
	}
	mana[pos]='!';
	for(int i=1;i<pos;i++){
		if(i<r)P[i]=min(r-i,P[2*c-i]);
		else P[i]=1;
		while(mana[P[i]+i]==mana[i-P[i]])P[i]++;
		if(i+P[i]>r){
			r=i+P[i];c=i;
		} 
		if(i==P[i])pre[ss+P[i]-2]=true;
		if(i+P[i]==pos)suf[ee-P[i]+1]=true;
	}
}

struct Tire
{
	int nxt[26];
	int count,leaf;
	void newnode()
	{
		memset(nxt,0,sizeof nxt);
		count=0,leaf=0;
	}
}T[maxn];

void insert(int ss,int ee)
{
	int rt=0;
	for(int i=ee-1;i>=ss;i--)
	{
		int k=s[i]-'a';
		if(pre[i])T[rt].count++;//表示下一个状态就是一个回文串 
		if(!T[rt].nxt[k])
		{
			T[rt].nxt[k]=++tot;
			T[tot].newnode();
		}
		rt=T[rt].nxt[k];
	}
	T[rt].leaf++;
}
long long ans;
void query(int ss,int ee)
{
	int rt=0;
	int i=0; 
	for(i=ss;i<ee;i++)
	{
		int k=s[i]-'a';
		if(!T[rt].nxt[k])
		{
			break;
		}
		rt=T[rt].nxt[k];
		if(suf[i+1]||i==ee-1){
			ans+=T[rt].leaf;//如果是前面有串的话， 
		}
	}
	if(i==ee){
		ans+=T[rt].count;
	}
}

int main()
{
	int n;
	while(~scanf("%d",&n))
	{
		ans=0;int l=0;tot=0;
		T[0].newnode(); 
		for(int i=1;i<=n;i++)
		{
			int len;
			scanf("%d %s",&len,s+l);
			str[i]=l,str[i+1]=l+len;
			l+=len;
			manacher(str[i],str[i+1]);
			insert(str[i],str[i+1]);
		}
		for(int i=1;i<=n;i++){
			query(str[i],str[i+1]);
		}
		cout<<ans<<endl;
	}
}
```

蛮难想到的题，注意字典树之间的配合。